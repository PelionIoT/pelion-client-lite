/*
 * Copyright (c) 2018 - 2019 ARM Limited. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "lwm2m_constants.h"
#include "lwm2m_endpoint.h"
#include "lwm2m_get_req_handler.h"
#include "lwm2m_interface.h"
#include "lwm2m_registry.h"
#include "lwm2m_registry_handler.h"
#include "lwm2m_storage.h"
#include "eventOS_event.h"
#include "eventOS_scheduler.h"
#include "include/CloudClientStorage.h"
#include "mbed-trace/mbed_trace.h"
#include "randLIB.h"

#ifdef MBED_CLOUD_CLIENT_FOTA_ENABLE
#include "fota/fota_app_ifs.h"
#endif

// Needed for PRIu64 on FreeRTOS
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TRACE_GROUP "lwIF"

#define LWM2M_INTERFACE_EVENT_INIT 51
#define LWM2M_INTERFACE_EXTERNAL_EVENT 52

#define REREGISTRATION_INTERVAL 70 // Percents of end point lifetime, re-registration interval = end point lifetime * (REREGISTRATION_INTERVAL / 100) s.

static void lwm2m_interface_notify_observer(lwm2m_interface_t *interface, lwm2m_interface_observer_event_t event_id, lwm2m_interface_error_t event_type);
static registry_status_t lwm2m_interface_registration_update_cb(registry_callback_type_t cb_type,
                                                         const registry_path_t *path,
                                                         const registry_callback_token_t *cb_token,
                                                         const registry_object_value_t *value,
                                                         const registry_notification_status_t status,
                                                         registry_t *registry);

static bool lwm2m_interface_set_registration_update_cb(lwm2m_interface_t *interface, registry_callback_t callback);
static bool lwm2m_interface_reset_timer(lwm2m_interface_t *interface, int8_t timer, int8_t tasklet_id, int32_t time_ms);
static lwm2m_interface_error_t lwm2m_interface_convert_protoman_to_client_error(int protoman_error);

/**
* Internal event generated by state machine.
* @param New State which the state machine should go to.
* @param data The data to be passed to the state machine.
*/
static void lwm2m_interface_internal_event(lwm2m_interface_t *interface, uint8_t, lwm2m_interface_event_data_u *event);
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static bool lwm2m_interface_is_bootstrap_waiting(lwm2m_interface_t *interface);
static bool lwm2m_interface_is_bootstrap_done(lwm2m_interface_t *interface);
static void lwm2m_interface_bootstrap_done(lwm2m_interface_t *interface);
static void lwm2m_interface_bootstrap_wait(lwm2m_interface_t *interface);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_client_registered(lwm2m_interface_t *interface);
static void lwm2m_interface_registration_updated(lwm2m_interface_t *interface);
static void lwm2m_interface_client_unregistered(lwm2m_interface_t *interface);
static void lwm2m_interface_connection_handler(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code);
static void lwm2m_interface_registration_error(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code);
static void lwm2m_interface_state_bootstrap_or_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data, bool bootstrap);

static void lwm2m_interface_endpoint_event_handler(arm_event_t *event);

/**
* State enumeration order must match the order of state
* method entries in the state map
*/
enum E_States {
    STATE_IDLE = 0,
    STATE_BOOTSTRAP,
    STATE_BOOTSTRAP_ADDRESS_RESOLVED,
    STATE_BOOTSTRAP_RESOURCE_CREATED,
    STATE_BOOTSTRAP_WAIT,
    STATE_BOOTSTRAP_ERROR_WAIT, // 5
    STATE_BOOTSTRAPPED,
    STATE_REGISTER,
    STATE_REGISTER_ADDRESS_RESOLVED,
    STATE_REGISTERED,
    STATE_UPDATE_REGISTRATION, // 10
    STATE_UNREGISTER,
    STATE_UNREGISTERED,
    STATE_SENDING_COAP_DATA,
    STATE_COAP_DATA_SENT,
    STATE_COAP_DATA_RECEIVED, // 15
    STATE_PROCESSING_COAP_DATA,
    STATE_COAP_DATA_PROCESSED,
    STATE_WAITING,
    STATE_MAX_STATES
};

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_bootstrap_error(lwm2m_interface_t *interface, const char *reason);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_timer_expired(lwm2m_interface_t *interface, lwm2m_interface_timer_id_t type);

// state machine state functions

/**
* When the state is Idle.
*/
static void lwm2m_interface_state_idle(lwm2m_interface_t *interface, lwm2m_interface_event_data_u* data);

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
/**
* When the client starts bootstrap.
*/
static void lwm2m_interface_state_bootstrap(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the bootstrap server address is resolved.
*/
static void lwm2m_interface_state_bootstrap_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the bootstrap resource is created.
*/
static void lwm2m_interface_state_bootstrap_resource_created(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the server has sent response and bootstrapping is done.
*/
static void lwm2m_interface_state_bootstrapped(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

/**
* When the client starts register.
*/
static void lwm2m_interface_state_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the server address for register is resolved.
*/
static void lwm2m_interface_state_register_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client is registered.
*/
static void lwm2m_interface_state_registered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client is updating registration.
*/
static void lwm2m_interface_state_update_registration(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client starts unregister.
*/
static void lwm2m_interface_state_unregister(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client has been unregistered.
*/
static void lwm2m_interface_state_unregistered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap data is been sent through socket.
*/
static void lwm2m_interface_state_sending_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap data is sent successfully.
*/
static void lwm2m_interface_state_coap_data_sent(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the socket has received coap data.
*/
static void lwm2m_interface_state_coap_data_received(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap message is being processed.
*/
static void lwm2m_interface_state_processing_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap message has been processed.
*/
static void lwm2m_interface_state_coap_data_processed(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client is waiting to receive or send data.
*/
static void lwm2m_interface_state_waiting(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
 * Start registration update.
 */
static void lwm2m_interface_start_register_update(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
 * @brief Redirects the state machine to right function.
 * @param current_state Current state to be set.
 * @param data Data to be passed to the state function.
 */
static void lwm2m_interface_state_function(lwm2m_interface_t *interface, lwm2m_interface_event_data_u* data);

/**
 * @brief State Engine maintaining state machine logic.
 */
static void lwm2m_interface_state_engine(lwm2m_interface_t *interface);

/**
* External event which can trigger the state machine.
* @param New The state to which the state machine should go.
* @param data The data to be passed to the state machine.
*/
static void lwm2m_interface_external_event(lwm2m_interface_t *interface, uint8_t, lwm2m_interface_event_data_u*);

/**
 * Helper method for extracting the IP address part and port from the
 * given server address.
 * @param server_address Source URL (without "coap" or "coaps" prefix).
 * @param ip_address The extracted IP.
 * @param port The extracted port.
 */
static void lwm2m_interface_process_address(lwm2m_interface_t *interface, const char* server_address, uint16_t* port);

/**
 * Helper method for storing the error description to _error_description if the feature
 * has not been turned off.
 * @param error description
 */
static void lwm2m_interface_set_error_description(lwm2m_interface_t *interface, const char *description);

static void lwm2m_interface_write_error_description(lwm2m_interface_t *interface, const char* reason, lwm2m_interface_error_t error_code);

static bool lwm2m_interface_create_endpoint(lwm2m_interface_t *interface,
                                        const char *type,
                                        const int32_t life_time,
                                        const int8_t event_handler_id);

static void lwm2m_interface_data_available(lwm2m_interface_t *interface, uint8_t* data,
                                    uint16_t data_size,
                                    const lwm2m_interface_socketaddress_t *address);

#if 0
static void lwm2m_interface_initialize_root_of_trust(void);
#endif

static void lwm2m_interface_connection_event_handler(connection_event_t event, void *impl, int error_code);

#define BEGIN_TRANSITION_MAP \
    static const uint8_t TRANSITIONS[] = {\

#define TRANSITION_MAP_ENTRY(entry)\
    entry,

#define END_TRANSITION_MAP(data) \
    0 };\
    lwm2m_interface_external_event(interface, TRANSITIONS[interface->current_state], data);

enum {
    EVENT_IGNORED = 0xFE,
    CANNOT_HAPPEN
};

static void lwm2m_interface_event_handler(arm_event_t *event)
{
    lwm2m_interface_t *interface = (lwm2m_interface_t*)event->data_ptr;
    tr_info("lwm2m_interface_event_handler() event id: %" PRId8 " event_type: %" PRId8, event->event_id, event->event_type);

    if (event->event_id == ENDPOINT_EVENT_ID) {
        lwm2m_interface_endpoint_event_handler(event);
    } else if (event->event_id >= LWM2M_INTERFACE_TIMER_REGISTRATION && event->event_id <= LWM2M_INTERFACE_TIMER_REREGISTRATION) {
        lwm2m_interface_timer_expired(interface, (lwm2m_interface_timer_id_t) event->event_id);
    } else if (event->event_id == LWM2M_INTERFACE_EXTERNAL_EVENT) {
        lwm2m_interface_internal_event(interface, (uint8_t) event->event_data, &interface->external_event_data);
    } else if (event->event_id == CONNECTION_EVENT_ID) {
        lwm2m_interface_connection_event_handler(event->event_type, interface, event->event_data);
    } else if (event->event_type == LWM2M_INTERFACE_EVENT_INIT) {
        // No need to do anything here.
    } else {
        tr_debug("lwm2m_interface_event_handler() unknown event id");
    }
}

static void lwm2m_interface_endpoint_event_handler(arm_event_t *event)
{
    lwm2m_interface_t *interface = (lwm2m_interface_t*)event->data_ptr;
    switch (event->event_type) {
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

        case ENDPOINT_EVENT_BOOTSTRAP_SENT:

            // No need to do anything here.
            break;

        case ENDPOINT_EVENT_BOOTSTRAP_READY:

            tr_info("interface_event_handler ENDPOINT_EVENT_BOOTSTRAP_READY");

// At least BG96 modem does not send disconnect event(PEER CLOSE NOTIFY) when server closes the bootstrap connection.
// Call directy bootstrap done which triggers the mds registration.
#ifdef PROTOMAN_OFFLOAD_TLS
            // Clear the pending request flag since close notification does not arrive.
            //interface->endpoint.send_queue.pending = false;
            lwm2m_interface_bootstrap_done(interface);

#else
            lwm2m_interface_bootstrap_wait(interface);
#endif

            break;

        case ENDPOINT_EVENT_ERROR_BOOTSTRAP:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_BOOTSTRAP");
            lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_BOOTSTRAP_FAILED);
            break;

#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
        case ENDPOINT_EVENT_REGISTERED:

            tr_info("interface_event_handler ENDPOINT_EVENT_REGISTERED");
            lwm2m_interface_client_registered(interface);
            break;

        case ENDPOINT_EVENT_DEREGISTERED:

            tr_info("interface_event_handler ENDPOINT_EVENT_DEREGISTERED");
            get_handler_free_get_request_list(NULL, true, ERROR_NOT_REGISTERED);
            lwm2m_interface_client_unregistered(interface);
            break;

        case ENDPOINT_EVENT_REREGISTERED:
            lwm2m_interface_registration_updated(interface);
            tr_info("interface_event_handler ENDPOINT_EVENT_REREGISTERED");
            break;

        /* Error cases
            * TODO: Check if this error handling is correct for every cases. */

        case ENDPOINT_EVENT_ERROR_REREGISTER:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_REREGISTER");
            if (event->event_data == ENDPOINT_EVENT_STATUS_TIMEOUT) {
                lwm2m_interface_connection_handler(interface, LWM2M_INTERFACE_ERROR_NETWORK_ERROR);
            } else {
                // Fallback to full registration if update has failed
                interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_UNKNOWN_ERROR);
            }
            break;

        case ENDPOINT_EVENT_ERROR_REGISTER:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_REGISTER");
            if (event->event_data == ENDPOINT_EVENT_STATUS_TIMEOUT) {
                lwm2m_interface_connection_handler(interface, LWM2M_INTERFACE_ERROR_NETWORK_ERROR);
            } else if (event->event_data == ENDPOINT_EVENT_STATUS_NO_MEMORY) {
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_MEMORY_FAIL);
            } else {
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_NOT_REGISTERED);
            }
            break;

        case ENDPOINT_EVENT_ERROR_DEREGISTER:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_DEREGISTER");
            get_handler_free_get_request_list(NULL, true, ERROR_NOT_REGISTERED);
            lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_UNREGISTRATION_FAILED);
            break;

        case ENDPOINT_EVENT_ERROR_TIMEOUT:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_NOTIFICATION_TIMEOUT");
            lwm2m_interface_connection_handler(interface, LWM2M_INTERFACE_ERROR_TIMEOUT);
            break;

        default:
            tr_error("interface_event_handler error: unknown event type");
            break;

    }
}

static void lwm2m_interface_connection_event_handler(connection_event_t event, void *impl, int error_code)
{
    lwm2m_interface_socketaddress_t address;
    lwm2m_interface_t *interface = (lwm2m_interface_t *)impl;
    uint8_t *data;
    size_t data_len = 0;

    switch(event) {

        case CONNECTION_EVENT_DATA:
            if (CONNECTION_STATUS_OK != connection_read_data(&interface->connection, &data, &data_len, (uint8_t **) &address.address, &address.length, &address.port)) {
                tr_warn("connection_event_handler connection_read_data failed.");
                return;
            }
            address.stack = address.length == 4 ? LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV4 : LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV6;
            lwm2m_interface_data_available(interface, data, data_len, &address);
            break;

        case CONNECTION_EVENT_CONNECTED:

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            if (!lwm2m_interface_is_bootstrap_done(interface)) {
                tr_info("connection_event_handler - STATE_BOOTSTRAP_ADDRESS_RESOLVED.");
                lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP_ADDRESS_RESOLVED, NULL);
            } else {
                tr_info("connection_event_handler - STATE_REGISTER_ADDRESS_RESOLVED.");
                lwm2m_interface_internal_event(interface, STATE_REGISTER_ADDRESS_RESOLVED, NULL);
            }
#else
            tr_info("connection_event_handler - STATE_REGISTER_ADDRESS_RESOLVED.");
            lwm2m_interface_internal_event(interface, STATE_REGISTER_ADDRESS_RESOLVED, NULL);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;

        case CONNECTION_EVENT_DISCONNECTED:

            tr_info("CONNECTION_EVENT_DISCONNECTED");
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            if (lwm2m_interface_is_bootstrap_waiting(interface)) {
                tr_info("connection_event_handler - CONNECTION_EVENT_DISCONNECTED.");
                lwm2m_interface_bootstrap_done(interface);
            } else {
                lwm2m_interface_connection_handler(interface, lwm2m_interface_convert_protoman_to_client_error(error_code));
            }
#else
            lwm2m_interface_connection_handler(interface, lwm2m_interface_convert_protoman_to_client_error(error_code));
#endif
            break;
        case CONNECTION_EVENT_ERROR:

            tr_info("CONNECTION_EVENT_ERROR");
            lwm2m_interface_connection_handler(interface, lwm2m_interface_convert_protoman_to_client_error(error_code));
            break;

        case CONNECTION_EVENT_DESTROYED:
            tr_info("CONNECTION_EVENT_DESTROYED");
            break;

        case CONNECTION_EVENT_DATA_SENT:
            lwm2m_interface_data_sent(interface);
            break;

        case CONNECTION_EVENT_INTERFACE_STATUS:

            tr_info("CONNECTION_EVENT_INTERFACE_STATUS %d", error_code);

            if (!error_code && interface->reconnecting &&
                interface->reconnection_time > (uint32_t)(interface->initial_reconnection_time * 2) &&
                interface->endpoint.message_type == ENDPOINT_MSG_UNDEFINED) {

                // Resume is used here for restarting the reconnection pattern.
                // This is only done when reconnection time is on average shorter than it would be without this call.
                tr_info("Calling lwm2m_interface_resume to reconnect.");
                lwm2m_interface_resume(interface);

            } else {
                tr_info("Status change ignored.");
            }

            break;

        default:

            break;

    }
}

void lwm2m_interface_init(lwm2m_interface_t *interface,
                          const uint16_t listen_port,
                          oma_lwm2m_binding_and_mode_t mode,
                          lwm2m_interface_network_stack_t stack)
{
    tr_debug("lwm2m_interface_init() -IN");
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->callback_handler = NULL;
#endif // MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->network_interface = NULL;
    interface->server_port = 0;
    interface->listen_port = listen_port;
    interface->current_state = STATE_IDLE;
    interface->binding_mode = mode;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
    interface->reconnecting = false;
    interface->retry_timer_expired = false;
    interface->bootstrapped = true; // True as default to get it working with connector only configuration
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->queue_mode_timer_ongoing = false;
#endif // #ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->unregister_ongoing = false;
    interface->event_ignored = false;
    interface->reconnect_attempt = 0;
    interface->event_handler_id = -1;
    interface->observer = NULL; // the lwm2m_interface_setup() will initialize the observation information
    interface->observer_id = -1;
    interface->observer_event.state = ARM_LIB_EVENT_UNQUEUED;
    interface->external_event.state = ARM_LIB_EVENT_UNQUEUED;
    interface->observer_event.allocator = ARM_LIB_EVENT_USER;
    interface->external_event.allocator = ARM_LIB_EVENT_USER;
    interface->initial_reconnection_time = 0;

    // Initializing internal protoman structure so that connection_close can be
    // called in any order.
    memset(&interface->connection.protoman, 0, sizeof(struct protoman_s));

    endpoint_init(&interface->endpoint,
                      &interface->connection,
                      (void *)interface,
                      (oma_lwm2m_binding_and_mode_t)(interface->binding_mode),
                      0);
}

bool lwm2m_interface_setup(lwm2m_interface_t *interface,
                           int8_t observer_id,
                           void *observer,
                           const char *endpoint_type,
                           const int32_t life_time,
                           const char *context_address)
{

    tr_debug("lwm2m_interface_setup()");
    // XXX: this needs to be changed to singleton, as the taskelts can not be destroyed and
    // a single tasklet is able to multiplex all the events to multiple instances.
    if (interface->event_handler_id < 0) {
        interface->event_handler_id = eventOS_event_handler_create(lwm2m_interface_event_handler, LWM2M_INTERFACE_EVENT_INIT);
    }

    if (interface->event_handler_id < 0) {
        tr_error("lwm2m_interface_setup() eventOS_event_handler_create failed!");
        return false;
    }

    interface->observer_id = observer_id;
    interface->observer = observer;

    //TODO:Increase the range from 1 to 100 seconds
    randLIB_seed_random();

    // Range is from 2 to 10
    interface->initial_reconnection_time = randLIB_get_random_in_range(2, 10);

    tr_info("lwm2m_interface_init() initial random time %d\n", interface->initial_reconnection_time);
    interface->reconnection_time = interface->initial_reconnection_time;

    initialize_storage();

#if 0
    lwm2m_interface_initialize_root_of_trust();
#endif

    if(!lwm2m_interface_create_endpoint(interface,
                                        endpoint_type,
                                        life_time,
                                        interface->event_handler_id)) {

        tr_error("lwm2m_interface_setup() create_endpoint failed!");
        lwm2m_interface_clean(interface);

        return false;
    }

    return true;
}

#if 0
static void lwm2m_interface_initialize_root_of_trust(void)
{

    // RoT key size is 128 bits
    const size_t max_size = 128/8;
    uint8_t buffer[max_size];
    size_t real_size = 0;
    bool success = false;

    if (CCS_STATUS_SUCCESS == get_config_parameter(ROOT_OF_TRUST, buffer, max_size, &real_size)) {
        tr_info("lwm2m_interface_initialize_root_of_trust() - read RoT from configuration, size %d", (int)real_size);
        success = true;
    }

    if (!success || real_size != max_size) {

        size_t len = 0;
#ifdef MBEDTLS_ENTROPY_HARDWARE_ALT
        // mbedtls can provide hardware-sourced random data if configured
        mbedtls_hardware_poll(NULL, (uint8_t *) &buffer, max_size, &len);

#elif MBED_CONF_MBED_CLOUD_CLIENT_USE_INSECURE_ROT
    #warning "You are using an insecure Root Of Trust implementation, DO NOT USE IN PRODUCTION ENVIRONMENTS. REPLACE WITH A PROPER IMPLEMENTATION BEFORE USE"
        tr_warn("lwm2m_interface_initialize_root_of_trust() Using insecure implementation to generate Root of Trust.");
        randLIB_get_n_bytes_random(&buffer, max_size);
        len = max_size;
#else
    #error "Please configure either a secure HW entropy source (MBEDTLS_ENTROPY_HARDWARE_ALT) or use insecure Root of Trust (MBED_CONF_MBED_CLIENT_USE_INSECURE_ROT) (NOT FOR PRODUCTION!)"
#endif

        if (len == max_size) {
            if (CCS_STATUS_SUCCESS != set_config_parameter(ROOT_OF_TRUST, buffer, max_size)) {
                tr_error("lwm2m_interface_initialize_root_of_trust() failed to store new RoT");
            }
        } else {
            tr_error("lwm2m_interface_initialize_root_of_trust() failed to generate new RoT");
        }
    }

    // don't leave the generated data to RAM
    memset(buffer, 0, max_size);
}
#endif

bool lwm2m_interface_create_endpoint(lwm2m_interface_t *interface,
                                     const char *type,
                                     const int32_t life_time,
                                     const int8_t event_handler_id)
{
    tr_info("lwm2m_interface_create_endpoint(type %s, lifetime %" PRId32 ", event_handler_id %" PRId8 ")",
            type, life_time, event_handler_id);

    if (endpoint_setup(&interface->endpoint, event_handler_id) != ENDPOINT_STATUS_OK) {
        return false;
    }

    if (!lwm2m_interface_set_registration_update_cb(interface, lwm2m_interface_registration_update_cb)) {
        return false;
    }

    bool endpoint_correct = endpoint_set_parameters(&interface->endpoint, type, life_time);

    if (!endpoint_correct) {
        tr_error("lwm2m_interface_create_endpoint() endpoint params are not valid");
    }

    return endpoint_correct;
}


bool lwm2m_interface_send_update_registration(lwm2m_interface_t *interface)
{
    return (ENDPOINT_STATUS_OK == endpoint_update_registration(&interface->endpoint));
}

static registry_status_t lwm2m_interface_registration_update_cb(registry_callback_type_t cb_type,
                                                         const registry_path_t *path,
                                                         const registry_callback_token_t *cb_token,
                                                         const registry_object_value_t *value,
                                                         const registry_notification_status_t status,
                                                         registry_t *registry)
{

    // XXX: we could encapsulate this better. digging struct internals tends to lead into trouble later on.
    endpoint_t *endpoint = registry->notifier->endpoint;

    if (REGISTRY_CALLBACK_EXECUTE == cb_type) {

        if (ENDPOINT_STATUS_OK != endpoint_update_registration(endpoint)) {
            tr_error("lwm2m_interface_registration_update_cb() failed to send update registration");
            return REGISTRY_STATUS_NO_MEMORY;
        }

        send_final_response(path, endpoint, cb_token->token, cb_token->token_size, COAP_MSG_CODE_RESPONSE_CHANGED, false);

    }

    return REGISTRY_STATUS_OK;
}

bool lwm2m_interface_set_registration_update_cb(lwm2m_interface_t *interface, registry_callback_t callback)
{
    registry_path_t path;
    registry_set_path(&path, M2M_SERVER_ID, 0, SERVER_REGISTRATION_UPDATE, 0, REGISTRY_PATH_RESOURCE);
    if (registry_set_callback(&interface->endpoint.registry, &path, callback) != REGISTRY_STATUS_OK) {
        return false;
    }
    return true;
}

static void lwm2m_interface_stop_timers(const int8_t event_handler_id)
{

    // No need to call the cancellations if the tasklet is not even created.
    // This is the case typically when the init() has been called before, but not setup().
    if (event_handler_id < 0) {
        return;
    }

    // It does not matter that some of the calls fail here as it just means that the timer was not active.
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_RETRY, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REREGISTRATION, event_handler_id);

}

void lwm2m_interface_stop(lwm2m_interface_t *interface)
{
    tr_debug("lwm2m_interface_stop() - IN");

    lwm2m_interface_stop_timers(interface->event_handler_id);

    endpoint_stop(&interface->endpoint);
    connection_close(&interface->connection);

    tr_debug("lwm2m_interface_stop() - OUT");
}

void lwm2m_interface_pause(lwm2m_interface_t *interface)
{
    tr_debug("lwm2m_interface_pause() - IN");

    lwm2m_interface_stop_timers(interface->event_handler_id);

    endpoint_stop(&interface->endpoint);

    connection_pause(&interface->connection);

    tr_debug("lwm2m_interface_pause() - OUT");
}

bool lwm2m_interface_resume(lwm2m_interface_t *interface)
{

#ifdef MBED_CONF_CLOUD_CLIENT_USE_SOFT_PAUSE_RESUME
    tr_debug("lwm2m_interface_resume() - soft, IN");
    connection_resume(&interface->connection);
#else
    tr_debug("lwm2m_interface_resume() - IN");
    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
    interface->reconnecting = false;
    interface->retry_timer_expired = false;
    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
    if (!lwm2m_interface_reset_timer(interface, LWM2M_INTERFACE_TIMER_RETRY, interface->event_handler_id, interface->reconnection_time * 1000)) {
        tr_error("lwm2m_interface_resume() lwm2m_interface_reset_timer Failed");
        return false;
    }
#endif
    tr_debug("lwm2m_interface_resume() - OUT");

    return true;

}

void lwm2m_interface_clean(lwm2m_interface_t *interface)
{
    tr_debug("lwm2m_interface_clean() - IN");

    lwm2m_interface_stop_timers(interface->event_handler_id);

    interface->observer = NULL;

    connection_destroy(&interface->connection);
    endpoint_destroy(&interface->endpoint);

    uninitialize_storage();

    tr_debug("lwm2m_interface_clean() - OUT");
}

void lwm2m_interface_bootstrap(lwm2m_interface_t *interface)
{
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    tr_debug("lwm2m_interface_bootstrap() - IN");

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_RETRY, interface->event_handler_id);

    // Transition to a new state based upon
    // the current state of the state machine
    lwm2m_interface_event_data_u data;
    data.security_data.security_instance = 0;
    BEGIN_TRANSITION_MAP                                    // - Current State -
        TRANSITION_MAP_ENTRY (STATE_BOOTSTRAP)              // state_idle
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (STATE_BOOTSTRAP)              // state_bootstrapped
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_registered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_sending_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_sent
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_received
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_processing_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_processed
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_waiting
    END_TRANSITION_MAP(&data)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        lwm2m_interface_set_error_description(interface, ERROR_REASON_2);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
    tr_debug("lwm2m_interface_bootstrap() - OUT");
#else
    lwm2m_interface_set_error_description(interface, ERROR_REASON_3);
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
}

void lwm2m_interface_cancel_bootstrap(lwm2m_interface_t *interface)
{
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
//TODO: Do we need this ?
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
}

void lwm2m_interface_register_object(lwm2m_interface_t *interface, uint16_t security_instance)
{
    tr_debug("lwm2m_interface_register_object - IN");
    // TODO: check that the security object instance exists
    if(false) {
        lwm2m_interface_set_error_description(interface, ERROR_REASON_4);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS);
        return;
    }
    // Transition to a new state based upon
    // the current state of the state machine
    lwm2m_interface_event_data_u data;
    data.security_data.security_instance = 0; //security;

    BEGIN_TRANSITION_MAP                                    // - Current State -
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_idle
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_bootstrapped
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_registered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_sending_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_sent
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_received
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_processing_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_processed
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_waiting
    END_TRANSITION_MAP(&data)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        lwm2m_interface_set_error_description(interface, ERROR_REASON_5);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
    tr_debug("lwm2m_interface_register_object - OUT");
}

void lwm2m_interface_update_registration(lwm2m_interface_t *interface, uint16_t security_instance, const uint32_t lifetime)
{
    tr_debug("lwm2m_interface_update_registration()");
    lwm2m_interface_event_data_u data;
    data.update_register_data.security_instance = security_instance;
    data.update_register_data.lifetime = lifetime;
    lwm2m_interface_start_register_update(interface, &data);
}

void lwm2m_interface_unregister_object(lwm2m_interface_t *interface)
{
    tr_debug("lwm2m_interface_unregister_object - current state %d", interface->current_state);
    // Transition to a new state based upon
    // the current state of the state machine
    BEGIN_TRANSITION_MAP                                // - Current State -
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_idle
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrapped
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_register
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_registered
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_sending_coap_data
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_coap_data_sent
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_coap_data_received
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_processing_coap_data
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_coap_data_processed
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_waiting
    END_TRANSITION_MAP(NULL)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        lwm2m_interface_set_error_description(interface, ERROR_REASON_6);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
    tr_debug("lwm2m_interface_unregister_object - OUT");
}

#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
void lwm2m_interface_set_queue_sleep_handler(lwm2m_interface_t *interface, interface_callback_handler handler)
{
    interface->callback_handler = handler;
}
#endif //#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE

void lwm2m_interface_set_random_number_callback(lwm2m_interface_t *interface, random_number_cb callback)
{
    // XXX: what was the old thing doing?
}
#ifndef PROTOMAN_OFFLOAD_TLS
void lwm2m_interface_set_entropy_callback(lwm2m_interface_t *interface, entropy_cb callback)
{
    if (connection_set_entropy_callback(&interface->connection, callback) < 0) {
        tr_error("lwm2m_interface_set_entropy_callback() failed to add entropy source");
    }
}
#endif // PROTOMAN_OFFLOAD_TLS

void lwm2m_interface_set_platform_network_handler(lwm2m_interface_t *interface, void *handler)
{
    interface->network_interface = handler;
}

static void lwm2m_interface_client_registered(lwm2m_interface_t *interface)
{
    tr_info("lwm2m_interface_client_registered");
    lwm2m_interface_internal_event(interface, STATE_REGISTERED, NULL);

#ifdef MBED_CLOUD_CLIENT_FOTA_ENABLE
    fota_app_resume();
#endif

    // Inform client is registered.
    // TODO: use server id as parameter?
    // TODO: check if above registration process goes to unregistration flow. Then this should not be called at all.
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_OBJECT_REGISTERED, LWM2M_INTERFACE_ERROR_NONE);
}

static void lwm2m_interface_registration_updated(lwm2m_interface_t *interface)
{
    tr_info("lwm2m_interface_registration_updated");
    lwm2m_interface_internal_event(interface, STATE_REGISTERED, NULL);
#ifdef MBED_CLOUD_CLIENT_FOTA_ENABLE
    fota_app_resume();
#endif
    // TODO: use server id as parameter?
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_REGISTRATION_UPDATED, LWM2M_INTERFACE_ERROR_NONE);
}

static void lwm2m_interface_registration_error(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code)
{
    tr_error("lwm2m_interface_registration_error code [%d]", error_code);

    endpoint_stop(&interface->endpoint);

    // Try to register again
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->queue_mode_timer_ongoing = false;
#endif //#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    if (error_code == LWM2M_INTERFACE_ERROR_UNREGISTRATION_FAILED) {

        interface->unregister_ongoing = false;
        interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION;


    } else if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE) {

        // If update registration failed again try full registration right away
        tr_info("Update registration retry failed, try full registration right away.");
        interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_FULL_REGISTRATION;
        if(ENDPOINT_STATUS_OK != endpoint_register(&interface->endpoint)) {
            // If resource creation fails then inform error to application
            tr_error("lwm2m_interface_registration_error endpoint_register: LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
            error_code = LWM2M_INTERFACE_ERROR_NOT_ALLOWED;
        } else {
            return;
        }

    }

    lwm2m_interface_connection_handler(interface, error_code);
}

static void lwm2m_interface_client_unregistered(lwm2m_interface_t *interface)
{
    tr_info("lwm2m_interface_client_unregistered()");
    interface->unregister_ongoing = false;
    lwm2m_interface_internal_event(interface, STATE_UNREGISTERED, NULL);
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_OBJECT_UNREGISTERED, LWM2M_INTERFACE_ERROR_NONE);
}

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_bootstrap_done(lwm2m_interface_t *interface)
{
    registry_path_t path;
    bool bootstrap;

    tr_info("lwm2m_interface_bootstrap_done");

    registry_set_path(&path, M2M_SECURITY_ID, 0, SECURITY_BOOTSTRAP_SERVER, 0, REGISTRY_PATH_RESOURCE);
    if (REGISTRY_STATUS_OK != registry_get_value_boolean(&interface->endpoint.registry, &path, &bootstrap)) {
        lwm2m_interface_bootstrap_error(interface, ERROR_REASON_12);
        return;
    }

    if (bootstrap) {
        if (!storage_set_bootstrap_credentials(&interface->endpoint.registry)) {
            lwm2m_interface_bootstrap_error(interface, ERROR_REASON_12);
            return;
        }
        lwm2m_interface_bootstrap(interface);
        return;
    }

    if (!storage_set_credentials(&interface->endpoint.registry)) {
        lwm2m_interface_bootstrap_error(interface, ERROR_REASON_26);
        return;
    }

    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnecting = false;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
    interface->bootstrapped = true;

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);

    lwm2m_interface_internal_event(interface, STATE_BOOTSTRAPPED, NULL);

    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_BOOTSTRAP_DONE, LWM2M_INTERFACE_ERROR_NONE);

}

static void lwm2m_interface_bootstrap_wait(lwm2m_interface_t *interface)
{

    tr_info("lwm2m_interface_bootstrap_wait");
    lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP_WAIT, NULL);
}

static void lwm2m_interface_bootstrap_error(lwm2m_interface_t *interface, const char *reason)
{

    tr_error("lwm2m_interface_bootstrap_error(%s)", reason);
    interface->bootstrapped = false;

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);
    connection_close(&interface->connection);

    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;

    lwm2m_interface_set_error_description(interface, reason);

    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_BOOTSTRAP_FAILED);

    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
    interface->reconnecting = true;

    interface->retry_timer_expired = false;
    lwm2m_interface_reset_timer(interface,
                                LWM2M_INTERFACE_TIMER_RETRY,
                                interface->event_handler_id,
                                interface->reconnection_time * 1000);

    tr_info("lwm2m_interface_bootstrap_error - reconnecting in %" PRIu32 "(s)", interface->reconnection_time);
    interface->reconnection_time = interface->reconnection_time * RECONNECT_INCREMENT_FACTOR;
    if(interface->reconnection_time >= MAX_RECONNECT_TIMEOUT) {
        interface->reconnection_time = MAX_RECONNECT_TIMEOUT;
    }

}
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_data_available(lwm2m_interface_t *interface,
                                    uint8_t* data,
                                    uint16_t data_size,
                                    const lwm2m_interface_socketaddress_t *address)
{
    tr_debug("lwm2m_interface_data_available");
    lwm2m_interface_event_data_u event;
    event.received_data.data = data;
    event.received_data.size = data_size;
    event.received_data.address = address;
    lwm2m_interface_internal_event(interface, STATE_COAP_DATA_RECEIVED, &event);
}

static void lwm2m_interface_connection_handler(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code)
{

    endpoint_stop(&interface->endpoint);
    connection_close(&interface->connection);
    if (interface->current_state == STATE_BOOTSTRAP_WAIT) {
        tr_debug("lwm2m_interface_connection_handler() bootstrap completed");
       // Bootstrap completed once PEER CLOSE notify received from the server.
       return;
    }

    tr_error("lwm2m_interface_connection_handler: (%d), reconnecting (%d), reconnection_state (%d)",
            error_code, interface->reconnecting, (int)interface->reconnection_state);

#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    // Ignore errors while client is sleeping
    if (lwm2m_interface_queue_mode(interface)) {
        if (interface->callback_handler && interface->queue_mode_timer_ongoing && error_code != LWM2M_INTERFACE_ERROR_TIMEOUT) {
            tr_info("lwm2m_interface_connection_handler - Queue Mode - don't try to reconnect while in QueueMode");
            return;
        }
        eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP, interface->event_handler_id);
    }
#endif //MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW, interface->event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);

    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);

    // Try to do reconnecting
    if (interface->reconnecting) {
        // If reconnecting has already failed, try lower level of reconnection if possible.
        if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_FULL_REGISTRATION) {
            interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
        } else if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION) {
            tr_info("lwm2m_interface_connection_handler - unreg failed again just call client_unregistered");
            lwm2m_interface_client_unregistered(interface);
            return;
        }
    }
    interface->reconnecting = true;
    interface->retry_timer_expired = false;
    lwm2m_interface_reset_timer(interface,
                                LWM2M_INTERFACE_TIMER_RETRY,
                                interface->event_handler_id,
                                interface->reconnection_time * 1000);

    tr_info("lwm2m_interface_connection_handler - reconnecting in %" PRIu32 "(s)", interface->reconnection_time);
    interface->reconnection_time = interface->reconnection_time * RECONNECT_INCREMENT_FACTOR;
    if (interface->reconnection_time >= MAX_RECONNECT_TIMEOUT) {
        interface->reconnection_time = MAX_RECONNECT_TIMEOUT;
    }

        lwm2m_interface_write_error_description(interface, ERROR_REASON_9, error_code);
    // Inform application after trying reconnection for MAX_RECONNECT_ATTEMPT times.
    if (interface->reconnect_attempt >= MAX_RECONNECT_ATTEMPT) {
        interface->reconnect_attempt = 0;
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, error_code);
    }
}

void lwm2m_interface_data_sent(lwm2m_interface_t *interface)
{
    tr_debug("lwm2m_interface_data_sent()");

#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    if (lwm2m_interface_queue_mode(interface) && interface->callback_handler) {

        if (interface->callback_handler && (interface->unregister_ongoing == false)) {

            lwm2m_interface_reset_timer(interface,
                                        LWM2M_INTERFACE_TIMER_QUEUE_SLEEP,
                                        interface->event_handler_id,
                                        MBED_CLIENT_RECONNECTION_COUNT*MBED_CLIENT_RECONNECTION_INTERVAL*1000*2);
        }
    }
#endif // #ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    if (interface->current_state == STATE_BOOTSTRAP_ERROR_WAIT) {
        // bootstrap_error to be called only after we have sent the last ACK.
        // Otherwise client will goto reconnection mode before ACK has sent.
        lwm2m_interface_bootstrap_error(interface, lwm2m_interface_error_description(interface));
    } else if (interface->current_state != STATE_BOOTSTRAP_WAIT) {
        lwm2m_interface_internal_event(interface, STATE_COAP_DATA_SENT, NULL);
    }
#else
    lwm2m_interface_internal_event(interface, STATE_COAP_DATA_SENT, NULL);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
}

static void lwm2m_interface_timer_expired(lwm2m_interface_t *interface, lwm2m_interface_timer_id_t type)
{
    if (LWM2M_INTERFACE_TIMER_REREGISTRATION == type) {
        lwm2m_interface_internal_event(interface, STATE_UPDATE_REGISTRATION, NULL);
    }
    else if (LWM2M_INTERFACE_TIMER_RETRY == type) {

        if (interface->reconnecting) {
            tr_debug("lwm2m_interface_timer_expired() - retry");
            interface->reconnect_attempt++;
            interface->retry_timer_expired = true;
        }

        lwm2m_interface_event_data_u data;
        data.security_data.security_instance = 0;
        if (interface->bootstrapped) {
            lwm2m_interface_internal_event(interface, STATE_REGISTER, &data);
        } else {
            lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP, &data);
        }
    }
    else if (LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW == type) {
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
        tr_debug("lwm2m_interface_timer_expired() - bootstrap");
        interface->bootstrapped = false;
        eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);
        lwm2m_interface_bootstrap_error(interface, ERROR_REASON_23);
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    }
    else if (LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW == type) {
        tr_debug("lwm2m_interface_timer_expired() - register");
        lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_TIMEOUT);
    }
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    else if(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP == type) {
        uint_fast16_t queue_size = 0;
#ifdef ENABLE_RESENDINGS
        queue_size = ns_list_count(&interface->endpoint.coap->linked_list_resent_msgs);
#endif
        if (queue_size > 0 || interface->reconnecting) {

            tr_debug("lwm2m_interface_timer_expired() - RESEND queue not empty or reconnection ongoing, continue sleep timer");
            lwm2m_interface_reset_timer(interface,
                                        LWM2M_INTERFACE_TIMER_QUEUE_SLEEP,
                                        interface->event_handler_id,
                                        MBED_CLIENT_RECONNECTION_COUNT * MBED_CLIENT_RECONNECTION_INTERVAL * 1000);

        } else {
            tr_debug("lwm2m_interface_timer_expired() - sleep");
            //TODO: Check if more actions needed here?
            interface->queue_mode_timer_ongoing = true;
            if(interface->callback_handler) {
                interface->callback_handler(interface->observer);
            }
        }
    }
#endif // MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
}

// state machine sits here.
static void lwm2m_interface_state_idle(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_idle");
    interface->unregister_ongoing = false; //TODO Check if this set should be done here?
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP, interface->event_handler_id);
}

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_state_bootstrap(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data) {
    lwm2m_interface_state_bootstrap_or_register(interface, data, true);
}
#endif

static void lwm2m_interface_state_bootstrap_or_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data, bool bootstrap)
{

    lwm2m_interface_error_t error = LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS;
    int64_t security_mode =  LWM2M_INTERFACE_SECURITY_MODE_PSK;
    char full_server_address[MAX_VALUE_LENGTH];
    int32_t full_server_address_size = MAX_VALUE_LENGTH - 1;
    char *server_address = NULL;
    char *full_server_address_end;
    bool security_available = false;
    const void *certificate = NULL;
    size_t certificate_size = 0;
    const void *key = NULL;
    size_t key_size = 0;
    const void *ca_certificate = NULL;
    size_t ca_certificate_size = 0;

    tr_debug("lwm2m_interface_state_bootstrap_or_register() bootstrap: %d", bootstrap);

    if (bootstrap) {
        tr_debug("lwm2m_interface_state_bootstrap_or_register() in bootstrap sequence");
        interface->bootstrapped = false;
    } else {
        tr_debug("lwm2m_interface_state_bootstrap_or_register() in register sequence");
        interface->listen_port = 0;
        storage_set_credentials(&interface->endpoint.registry);
    }

    full_server_address_end = storage_read_uri(full_server_address, &full_server_address_size, bootstrap);
    *full_server_address_end = '\0';

    if (strlen(full_server_address)) {
        tr_debug("lwm2m_interface_state_bootstrap_or_register - server_address %s", full_server_address);

        if (strstr(full_server_address, COAP)) {
            server_address = full_server_address + strlen(COAP);
            security_mode = LWM2M_INTERFACE_SECURITY_MODE_NO_SECURITY;
        }
        else if (strstr(full_server_address, COAPS)) {
            server_address = full_server_address + strlen(COAPS);
        }

        uint8_t connection_mode = CONNECTION_MODE_UDP;

#if defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP_QUEUE)
        if (interface->binding_mode == BINDING_MODE_T_Q || interface->binding_mode == BINDING_MODE_T) {
            connection_mode = CONNECTION_MODE_TCP;
        }
#endif
        lwm2m_interface_process_address(interface, server_address, &interface->server_port);

        tr_debug("lwm2m_interface_state_bootstrap_or_register - IP address %s , Port %d", interface->server_ip_address, interface->server_port);
        // If bind and resolving server address succeed then proceed else
        // return error to the application and go to Idle state.
        if(strlen(interface->server_ip_address) != 0) {

            lwm2m_interface_reset_timer(interface,
                                        bootstrap ? LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW : LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW,
                                        interface->event_handler_id,
                                        MBED_CLIENT_RECONNECTION_COUNT * MBED_CLIENT_RECONNECTION_INTERVAL * 8 * 1000);

            if (security_mode != LWM2M_INTERFACE_SECURITY_MODE_NO_SECURITY) {

                connection_mode |= CONNECTION_MODE_FLAG_SECURE;
#ifdef PROTOMAN_SECURITY_ENABLE_CERTIFICATE

#ifdef PROTOMAN_OFFLOAD_TLS
                security_available = true;
#else
                certificate = storage_read_certificate(&certificate_size, bootstrap);
                key = storage_read_certificate_key(&key_size, bootstrap);
                ca_certificate = storage_read_ca_certificate(&ca_certificate_size, bootstrap);

                if (certificate && key && ca_certificate) {
                    security_available = true;
                }
#endif

#elif defined(PROTOMAN_SECURITY_ENABLE_PSK)

                size_t size;
                size = sizeof(interface->psk);
                security_available = storage_read_psk(interface->psk, &size, bootstrap);
                interface->psk_size = size;

                if (security_available) {
                    size = sizeof(interface->psk_id);
                    security_available = storage_read_psk_id(interface->psk_id, &size, bootstrap);
                    interface->psk_id_size = size;
                }

                if (security_available) {

                    certificate = interface->psk_id;
                    certificate_size = interface->psk_id_size;
                    key = interface->psk;
                    key_size = interface->psk_size;

                }

#endif
            }

            if (security_available || security_mode == LWM2M_INTERFACE_SECURITY_MODE_NO_SECURITY) {

                connection_close(&interface->connection);

                if (CONNECTION_STATUS_OK == connection_init(&interface->connection, &lwm2m_interface_connection_event_handler,interface->event_handler_id , interface, interface->server_ip_address, interface->server_port,
                                                            connection_mode, interface->network_interface,
                                                            ca_certificate, ca_certificate_size, certificate,
                                                            certificate_size, key, key_size
#if defined(PROTOMAN_USE_SSL_SESSION_RESUME) || defined(PROTOMAN_OFFLOAD_TLS)
                                                            , bootstrap
#endif
                                                            )) {
                    error = LWM2M_INTERFACE_ERROR_NONE;
                    connection_start(&interface->connection);
                }

            }

        }
    }

    // XXX: still needed? fast fail could be easier to pull off if this were a function.
    if (error != LWM2M_INTERFACE_ERROR_NONE) {
        tr_error("lwm2m_interface_state_bootstrap_or_register - set error as LWM2M_INTERFACE_INVALID_PARAMETERS");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_11);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, error);
    }

}

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_state_bootstrap_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    (void)data;

    tr_debug("lwm2m_interface_state_bootstrap_address_resolved()");

    if(ENDPOINT_STATUS_OK == endpoint_bootstrap(&interface->endpoint)) {
       lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP_RESOURCE_CREATED, NULL);
    } else{
        // If resource creation fails then inform error to application
        tr_error("lwm2m_interface_state_bootstrap_address_resolved : LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_12);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
}

static void lwm2m_interface_state_bootstrap_resource_created(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_bootstrap_resource_created");
}

static void lwm2m_interface_state_bootstrapped(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_bootstrapped");
    connection_close(&interface->connection);
}
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_state_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_register");
    lwm2m_interface_state_bootstrap_or_register(interface, data, false);
}

// TODO: change this to take in just the destination pointer instead of the whole interface
static void lwm2m_interface_process_address(lwm2m_interface_t *interface, const char *server_address, uint16_t* port)
{
    memset(interface->server_ip_address, 0 ,MAX_ALLOWED_IP_STRING_LENGTH);
    const char* colon = strrchr(server_address, ':');
    if (!colon) {
        return;
    }

    int colonFound = colon - server_address + 1;
    if(colonFound > 0) {
        memcpy(interface->server_ip_address, server_address, strlen(server_address) - strlen(colon));
        colon += 1;
        *port = atoi(colon);
        const char* end = strrchr(interface->server_ip_address, ']');
        if (end) {
            colonFound = end - interface->server_ip_address + 1;
            if(strncmp(interface->server_ip_address, "[", 1) == 0) {
                if(colonFound < 0) {
                    memset(interface->server_ip_address, 0, MAX_ALLOWED_IP_STRING_LENGTH);
                } else {
                    memmove(interface->server_ip_address, interface->server_ip_address+1, colonFound-1);
                    interface->server_ip_address[colonFound] = '\0';
                }
            } else if(colonFound > 0) {
                memset(interface->server_ip_address, 0, MAX_ALLOWED_IP_STRING_LENGTH);
            }
        }
    }
}

bool lwm2m_interface_queue_mode(const lwm2m_interface_t *interface)
{
    if((interface->binding_mode == BINDING_MODE_Q)
#if defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP_QUEUE)
       || (interface->binding_mode == BINDING_MODE_T_Q)
#endif
       ) {
        return true;
    }
    return false;
}

static void lwm2m_interface_state_register_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    uint8_t *address;
    uint8_t address_len;
    uint16_t port;

    (void)data;

    tr_debug("lwm2m_interface_state_register_address_resolved");

    connection_get_server_address(&interface->connection, &address, &address_len, &port);

    if(address_len == 4) {
        tr_info("lwm2m_interface_state_register_address_resolved : IPv4 address");

    } else {
        tr_info("lwm2m_interface_state_register_address_resolved : IPv6 address");
    }

    switch (interface->reconnection_state) {
        case LWM2M_INTERFACE_RECONNECTION_STATE_NONE:
        case LWM2M_INTERFACE_RECONNECTION_STATE_FULL_REGISTRATION:
            if(ENDPOINT_STATUS_OK != endpoint_register(&interface->endpoint)) {
                // If resource creation fails then inform error to application
                tr_error("lwm2m_interface_state_register_address_resolved : LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
                lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
                lwm2m_interface_set_error_description(interface, ERROR_REASON_25);
                lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
            }
            break;
        case LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE:
            // Start registration update in case it is reconnection logic because of network issue.
            lwm2m_interface_internal_event(interface, STATE_UPDATE_REGISTRATION, NULL);
            break;
        case LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION:
            lwm2m_interface_internal_event(interface, STATE_UNREGISTER, NULL);
            break;
    }

}

static void lwm2m_interface_state_registered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    uint32_t lifetime = MINIMUM_REGISTRATION_TIME;
    uint16_t registration_percent = REREGISTRATION_INTERVAL;

    tr_info("lwm2m_interface_state_registered");

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW, interface->event_handler_id);

    if (ENDPOINT_STATUS_OK == endpoint_get_lifetime(&interface->endpoint, &lifetime)) {


        // If it is a UDP or UDP_QUEUE mode, we need to scale down the registration update time based
        // on lifetime values,
        // Lifetime values upto 300 seconds , registration update should be triggered at 50% of lapsed lifetime
        // Lifetime values upto 600 seconds , registration update should be triggered at 60% of lapsed lifetime
        // Lifetime values more than 600 seconds , registration update should be triggered at 70% of lapsed
        // lifetime like normal registration update
        if (interface->binding_mode == BINDING_MODE_U ||
            interface->binding_mode == (BINDING_MODE_U | BINDING_MODE_Q)) {
            if (lifetime <= 300) {
                registration_percent = REREGISTRATION_UDP_QUEUE_LOW_INTERVAL;
            } else if (lifetime <= 600) {
                registration_percent = REREGISTRATION_UDP_QUEUE_INTERMEDIATE_INTERVAL;
            }
        }

        if (lifetime < MINIMUM_REGISTRATION_TIME) {
            lifetime = MINIMUM_REGISTRATION_TIME;
        }

#ifdef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
        // If bootstrap is disabled internal endpoint name isn't available other than if parsed from the
        // location path of the registration response message. Parse and store it here.
        const char *iep = interface->endpoint.location;
        int count = 0;

        // Find the string following the second "/" character in the endpoint location-path
        // The format should be "rd/<aid>/<iep>"
        while (iep = strstr(iep, "/")) {
            iep++;
            if (++count == 2) {
                break;
            }
        }

        if (iep && strlen(iep) > 0) {
            if (!storage_set_internal_endpoint_name(iep)) {
                tr_error("lwm2m_interface_state_registered() error storing internal endpoint name");
            }
        } else {
            tr_error("lwm2m_interface_state_registered() failed to parse internal endpoint name");
        }

#endif
    } else {
        tr_error("lwm2m_interface_state_registered() error reading endpoint lifetime");
    }

    lwm2m_interface_reset_timer(interface,
                                LWM2M_INTERFACE_TIMER_REREGISTRATION,
                                interface->event_handler_id,
                                lifetime * 10 * registration_percent);

    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnecting = false;

    // Continue with the unregistration process if it has failed due to connection lost
    if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION) {
        lwm2m_interface_internal_event(interface, STATE_UNREGISTER, NULL);
    } else {
        interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
    }
}

static void lwm2m_interface_state_update_registration(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_update_registration");
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    // Set to false to allow reconnection to work.
    interface->queue_mode_timer_ongoing = false;
#endif // #ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE

    if (data) {

        uint32_t new_lifetime = data->update_register_data.lifetime;

        endpoint_set_lifetime(&interface->endpoint, new_lifetime);

    } else {
        tr_debug("lwm2m_interface_state_update_registration() no event data found");
    }

    if (ENDPOINT_STATUS_OK != endpoint_update_registration(&interface->endpoint)) {

        tr_error("lwm2m_interface_state_update_registration : LWM2M_INTERFACE_ERROR_MEMORY_FAIL");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_25);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);

    }
}

static void lwm2m_interface_state_unregister(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_unregister");
    if (interface->unregister_ongoing) {
        tr_warn("lwm2m_interface_state_unregister : _unregister_ongoing");
        return;
    }
    lwm2m_interface_internal_event(interface, STATE_SENDING_COAP_DATA, NULL);
    if (ENDPOINT_STATUS_OK != endpoint_unregister(&interface->endpoint)) {
        tr_error("lwm2m_interface_state_unregister : LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_5);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
        return;
    }
    interface->unregister_ongoing = true;
}

static void lwm2m_interface_state_unregistered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_info("lwm2m_interface_state_unregistered");
    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
    connection_close(&interface->connection);
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_OBJECT_UNREGISTERED, LWM2M_INTERFACE_ERROR_NONE);
    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
}

static void lwm2m_interface_state_sending_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    //NOTE: This function is no-longer used.
    tr_debug("lwm2m_interface_state_sending_coap_data");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_coap_data_sent(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_coap_data_sent");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_coap_data_received(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{

    tr_debug("lwm2m_interface_state_coap_data_received");

    if(data) {
        lwm2m_interface_received_data_t event = data->received_data;

        sn_nsdl_addr_s address;

        lwm2m_interface_network_stack_t stack = event.address->stack;

        if(LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV4 == stack) {
            address.type = SN_NSDL_ADDRESS_TYPE_IPV4;
            address.addr_len = 4;
        } else if((LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV6 == stack) ||
                  (LWM2M_INTERFACE_NETWORK_STACK_NANOSTACK_IPV6 == stack)) {
            address.type = SN_NSDL_ADDRESS_TYPE_IPV6;
            address.addr_len = 16;
        }
        address.port = event.address->port;
        address.addr_ptr = (uint8_t*)event.address->address;
        address.addr_len = event.address->length;

        // Process received data
        lwm2m_interface_internal_event(interface, STATE_PROCESSING_COAP_DATA, NULL);
        if(ENDPOINT_STATUS_OK != endpoint_process_coap(&interface->endpoint, event.data, event.size, &address)) {
           tr_error("lwm2m_interface_state_coap_data_received : LWM2M_INTERFACE_ERROR_RESPONSE_PARSE_FAILED");
           lwm2m_interface_set_error_description(interface, ERROR_REASON_17);
           lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_RESPONSE_PARSE_FAILED);

// With BG96 first message(BS POST) is corrupted and queue flag is not automatically cleared.
// Let's do it here as a workaround otherwise first try against mds will lead to reconnection.
#ifdef PROTOMAN_OFFLOAD_TLS
           interface->endpoint.send_queue.sending_in_progress = false;
#endif
        }
        lwm2m_free(event.data);
    }

}

static void lwm2m_interface_state_processing_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_processing_coap_data");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_coap_data_processed(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_coap_data_processed");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_waiting(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("lwm2m_interface_state_waiting");
}

// generates an external event. called once per external event
// to start the state machine executing
static void lwm2m_interface_external_event(lwm2m_interface_t *interface,
                                    uint8_t new_state,
                                    lwm2m_interface_event_data_u* p_data)
{
    tr_debug("lwm2m_interface_external_event : new state %d", new_state);
    // if we are supposed to ignore this event
    if (new_state == EVENT_IGNORED) {
        tr_debug("lwm2m_interface_external_event : new state is EVENT_IGNORED");
        interface->event_ignored = true;
    }
    else {
        tr_debug("lwm2m_interface_external_event : handle new state");

        eventOS_cancel(&interface->external_event);

        // we generate a preallocated event, which will be handled by lwm2m_interface_external_event_handler()
        interface->external_event.data.event_data = new_state;
        interface->external_event.data.data_ptr = interface;
        interface->external_event.data.receiver = interface->event_handler_id;
        interface->external_event.data.sender = 0;
        interface->external_event.data.event_id = LWM2M_INTERFACE_EXTERNAL_EVENT;
        interface->external_event.data.priority = ARM_LIB_LOW_PRIORITY_EVENT;
        interface->external_event.data.event_type = 0;
        if (p_data) {
            interface->external_event_data = *p_data;
        }

        eventOS_event_send_user_allocated(&interface->external_event);
    }
}

// generates an internal event. called from within a state
// function to transition to a new state
static void lwm2m_interface_internal_event(lwm2m_interface_t *interface,
                                    uint8_t new_state,
                                    lwm2m_interface_event_data_u* p_data)
{
    tr_debug("lwm2m_interface_internal_event : new state %d", new_state);
    interface->event_data = p_data;
    interface->event_generated = true;
    interface->current_state = new_state;
    lwm2m_interface_state_engine(interface);
}

// the state engine executes the state machine states
static void lwm2m_interface_state_engine (lwm2m_interface_t *interface)
{
    tr_debug("lwm2m_interface_state_engine");
    lwm2m_interface_event_data_u* p_data_temp = NULL;

    // while events are being generated keep executing states
    while (interface->event_generated) {
        p_data_temp = interface->event_data;  // copy of event data pointer
        interface->event_data = NULL;       // event data used up, reset ptr
        interface->event_generated = false;  // event used up, reset flag

        assert(interface->current_state < STATE_MAX_STATES);

        lwm2m_interface_state_function(interface, p_data_temp);
    }
}

static void lwm2m_interface_state_function(lwm2m_interface_t *interface, lwm2m_interface_event_data_u* data)
{
    switch( interface->current_state ) {
        case STATE_IDLE:
            lwm2m_interface_state_idle(interface, data);
            break;
        case STATE_BOOTSTRAP:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrap(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAP_ADDRESS_RESOLVED:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrap_address_resolved(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAP_RESOURCE_CREATED:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrap_resource_created(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAP_WAIT:
        case STATE_BOOTSTRAP_ERROR_WAIT:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            // Do nothing, we're just waiting for data_sent callback
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAPPED:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrapped(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_REGISTER:
            lwm2m_interface_state_register(interface, data);
            break;
        case STATE_REGISTER_ADDRESS_RESOLVED:
            lwm2m_interface_state_register_address_resolved(interface, data);
            break;
        case STATE_REGISTERED:
            lwm2m_interface_state_registered(interface, data);
            break;
        case STATE_UPDATE_REGISTRATION:
            lwm2m_interface_state_update_registration(interface, data);
            break;
        case STATE_UNREGISTER:
            lwm2m_interface_state_unregister(interface, data);
            break;
        case STATE_UNREGISTERED:
            lwm2m_interface_state_unregistered(interface, data);
            break;
        case STATE_SENDING_COAP_DATA:
            lwm2m_interface_state_sending_coap_data(interface, data);
            break;
        case STATE_COAP_DATA_SENT:
            lwm2m_interface_state_coap_data_sent(interface, data);
            break;
        case STATE_COAP_DATA_RECEIVED:
            lwm2m_interface_state_coap_data_received(interface, data);
            break;
        case STATE_PROCESSING_COAP_DATA:
            lwm2m_interface_state_processing_coap_data(interface, data);
            break;
        case STATE_COAP_DATA_PROCESSED:
            lwm2m_interface_state_coap_data_processed(interface, data);
            break;
        case STATE_WAITING:
            lwm2m_interface_state_waiting(interface, data);
            break;
    }
}

void lwm2m_interface_start_register_update(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data) {
    tr_debug("lwm2m_interface_start_register_update()");

    if(!data || (data->update_register_data.lifetime != 0 && (data->update_register_data.lifetime < MINIMUM_REGISTRATION_TIME))) {
        lwm2m_interface_set_error_description(interface, ERROR_REASON_18);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS);
    }

    if (interface->reconnecting) {
        //If client is in reconnection mode, ignore this call, state machine will reconnect on its own.
        return;
    }

    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
    BEGIN_TRANSITION_MAP                                    // - Current State -
        TRANSITION_MAP_ENTRY (STATE_REGISTER)                // state_idle
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrapped
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (STATE_UPDATE_REGISTRATION)    // state_registered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_sending_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_sent
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_received
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_processing_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_processed
        TRANSITION_MAP_ENTRY (STATE_UPDATE_REGISTRATION)    // state_waiting
    END_TRANSITION_MAP(data)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        if (!interface->reconnecting) {
            lwm2m_interface_set_error_description(interface, ERROR_REASON_19);
            lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
        }
    }
}

void lwm2m_interface_update_endpoint(lwm2m_interface_t *interface, const char *name)
{
    //todo endpoint_set_parameters(&interface->endpoint, name, NULL, 0, NULL, NULL, 0);
}

void lwm2m_interface_update_domain(lwm2m_interface_t *interface, const char *domain)
{
    //todo endpoint_set_parameters(&interface->endpoint, NULL, NULL, 0, domain, NULL, 0);
}

const char* lwm2m_interface_internal_endpoint_name_str(const lwm2m_interface_t *interface)
{
    const char *iep = NULL;

    if (interface->endpoint.location) {
        // Get last part of the location path.
        // In mbed Cloud environment full path is /rd/accountid/internal_endpoint
        iep = strrchr(interface->endpoint.location, '/');
        iep += 1;
    }

    return iep;
}


const char *lwm2m_interface_error_description(const lwm2m_interface_t *interface)
{
#ifdef DISABLE_ERROR_DESCRIPTION
    (void)interface;
    return "";
#else
    return interface->error_description;
#endif
}

void lwm2m_interface_set_error_description(lwm2m_interface_t *interface, const char *description)
{
#ifdef DISABLE_ERROR_DESCRIPTION
    (void)interface;
    (void)description;
#else
    interface->error_description = description;
#endif
}

bool lwm2m_interface_is_bootstrap_done(lwm2m_interface_t *interface)
{
    return interface->bootstrapped;
}

bool lwm2m_interface_is_bootstrap_waiting(lwm2m_interface_t *interface)
{
    return (interface->current_state == STATE_BOOTSTRAP_WAIT);
}


static void lwm2m_interface_write_error_description(lwm2m_interface_t *interface, const char* reason, lwm2m_interface_error_t error_code)
{
    // Check that descriptions fits into buffer
#ifdef DISABLE_ERROR_DESCRIPTION
    (void)interface;
    (void)reason;
    (void)error_code;
#else
    const char *desc;
    switch(error_code) {
        case LWM2M_INTERFACE_ERROR_DNS_RESOLVING_FAILED:
            desc = ERROR_DNS;
            break;
        case LWM2M_INTERFACE_ERROR_SECURE_CONNECTION_FAILED:
            desc = ERROR_SECURE_CONNECTION;
            break;
        case LWM2M_INTERFACE_ERROR_CERTIFICATE_FAILED:
            desc = ERROR_CERTIFICATE_FAIL;
            break;
        case LWM2M_INTERFACE_ERROR_PLATFORM_FAULT:
            desc = ERROR_PLATFORM_FAIL;
            break;
        case LWM2M_INTERFACE_ERROR_INTERNAL_FAILURE:
            desc = ERROR_INTERNALFAILURE;
            break;
        case LWM2M_INTERFACE_ERROR_NETWORK_ERROR:
            desc = ERROR_NETWORK;
            break;
        case LWM2M_INTERFACE_ERROR_MEMORY_FAIL:
            desc = ERROR_MEMORY_FAIL;
            break;
        case LWM2M_INTERFACE_ERROR_UNREGISTRATION_FAILED:
            desc = ERROR_UNREGISTER_FAIL;
            break;
        default:
            desc = ERROR_NETWORK;
            break;
    }
    //todo: do we need the reason?
    interface->error_description = desc;

#endif
}


void lwm2m_interface_get_data_request(lwm2m_interface_t *interface,
                                      DownloadType type,
                                      const char *uri,
                                      const size_t offset,
                                      const bool async,
                                      get_data_cb data_cb,
                                      get_data_error_cb error_cb,
                                      void *context)
{
    get_data_req_error_t error = FAILED_TO_SEND_MSG;

    if (interface->unregister_ongoing) {
        tr_error("lwm2m_interface_get_data_request - unregister_ongoing!");
        error_cb(ERROR_NOT_REGISTERED, context);
        return;
    }

    if (uri) {
        get_handler_send_get_data_request(&interface->endpoint, type, uri, offset, async, data_cb, error_cb, context);
    } else {
        error_cb(error, context);
    }
}

bool lwm2m_interface_set_uri_query_parameters(lwm2m_interface_t *interface, const char *uri_query_params)
{
    return endpoint_set_uri_query_parameters(&interface->endpoint, uri_query_params);
}

static void lwm2m_interface_notify_observer(lwm2m_interface_t *interface, lwm2m_interface_observer_event_t event_id, lwm2m_interface_error_t event_type)
{
    if (interface->observer_id < 0 || !interface->observer) {
        tr_error("lwm2m_interface_notify_observer() no observer set");
        return;
    }

    eventOS_cancel(&interface->observer_event);

    // we generate a preallocated event, which will be handled by the observer
    interface->observer_event.data.data_ptr = interface->observer;
    interface->observer_event.data.receiver = interface->observer_id;
    interface->observer_event.data.sender = 0;
    interface->observer_event.data.event_id = event_id;
    interface->observer_event.data.event_type = event_type;
    interface->observer_event.data.priority = ARM_LIB_LOW_PRIORITY_EVENT;

    eventOS_event_send_user_allocated(&interface->observer_event);
}

static bool lwm2m_interface_reset_timer(lwm2m_interface_t *interface, int8_t timer, int8_t tasklet_id, int32_t time_ms) {

    arm_event_t event;

    event.data_ptr = interface;
    event.event_data = 0;
    event.event_id = timer;
    event.event_type = 0; // Currently we have no use for event type.
    event.priority = ARM_LIB_LOW_PRIORITY_EVENT;
    event.receiver = tasklet_id;
    event.sender = tasklet_id;

    eventOS_event_timer_cancel(timer, tasklet_id);

    if (!eventOS_event_timer_request_in(&event, eventOS_event_timer_ms_to_ticks(time_ms))) {
        tr_error("lwm2m_interface_reset_timer() call to eventOS_event_timer_request_in() failed!");
        return false;
    }

    return true;
}

static lwm2m_interface_error_t lwm2m_interface_convert_protoman_to_client_error(int protoman_error) {
    tr_error("lwm2m_interface_convert_protoman_to_client_error - protoman error %d", protoman_error);
    lwm2m_interface_error_t error = LWM2M_INTERFACE_ERROR_NETWORK_ERROR;
    switch(protoman_error) {
        case PROTOMAN_ERR_DNS_RESOLVING_FAILED:
            error = LWM2M_INTERFACE_ERROR_DNS_RESOLVING_FAILED;
            break;
        case PROTOMAN_ERR_SECURE_CONNECTION_FAILED:
            error = LWM2M_INTERFACE_ERROR_SECURE_CONNECTION_FAILED;
            break;
        case PROTOMAN_ERR_CERTIFICATE_CHECK_FAILED:
            error = LWM2M_INTERFACE_ERROR_CERTIFICATE_FAILED;
            break;
        case PROTOMAN_ERR_PLATFORM_FAULT:
            error = LWM2M_INTERFACE_ERROR_PLATFORM_FAULT;
            break;
        case PROTOMAN_ERR_INTERNAL_ERROR:
            error = LWM2M_INTERFACE_ERROR_INTERNAL_FAILURE;
            break;
        case PROTOMAN_ERR_NETWORK_ERROR:
        case PROTOMAN_ERR_CONNECTION_REFUSED:
            error = LWM2M_INTERFACE_ERROR_NETWORK_ERROR;
            break;
        default:
            error = LWM2M_INTERFACE_ERROR_NETWORK_ERROR; // default to network error
            break;
    }
    return error;
}
