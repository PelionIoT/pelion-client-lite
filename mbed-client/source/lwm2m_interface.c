/*
 * Copyright (c) 2018 - 2019 ARM Limited. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "lwm2m_constants.h"
#include "lwm2m_endpoint.h"
#include "lwm2m_req_handler.h"
#include "lwm2m_interface.h"
#include "lwm2m_registry.h"
#include "lwm2m_registry_handler.h"
#include "lwm2m_storage.h"
#include "eventOS_event.h"
#include "eventOS_scheduler.h"
#include "include/CloudClientStorage.h"
#include "mbed-trace/mbed_trace.h"
#include "randLIB.h"

#ifdef MBED_CLOUD_CLIENT_FOTA_ENABLE
#include "fota/fota_internal_ifs.h"
#endif

// Needed for PRIu64 on FreeRTOS
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TRACE_GROUP "lwIF"

#define MBED_ASSERT(expr) do { assert(expr); } while(0)

#define LWM2M_INTERFACE_EVENT_INIT 51
#define LWM2M_INTERFACE_EXTERNAL_EVENT 52

#define REREGISTRATION_INTERVAL 70 // Percents of end point lifetime, re-registration interval = end point lifetime * (REREGISTRATION_INTERVAL / 100) s.

#ifdef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
static const char *lifetime_res_id = "/1/0/1";
static const char *binding_res_id = "/1/0/7";
static const char *reg_update_res_id = "/1/0/8";
#endif

static int8_t event_handler_id = -1;

#ifdef CPPUTEST_COMPILATION
//  Unittests need to be able to start running from a pristine state
void unittest_lwm2m_interface_reset_global_variables(void)
{
    event_handler_id = -1;
}
#endif

static void lwm2m_interface_notify_observer(lwm2m_interface_t *interface, lwm2m_interface_observer_event_t event_id, lwm2m_interface_error_t event_type);
#ifndef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
static registry_status_t lwm2m_interface_registration_update_cb(registry_callback_type_t cb_type,
                                                         const registry_path_t *path,
                                                         const registry_callback_token_t *cb_token,
                                                         const registry_object_value_t *value,
                                                         const registry_notification_status_t status,
                                                         registry_t *registry);

static bool lwm2m_interface_set_registration_update_cb(lwm2m_interface_t *interface, registry_callback_t callback);
#endif

static bool lwm2m_interface_reset_timer(lwm2m_interface_t *interface, int8_t timer, int8_t tasklet_id, int32_t time_ms);
static lwm2m_interface_error_t lwm2m_interface_convert_protoman_to_client_error(int protoman_error);

/**
* Internal event generated by state machine.
* @param New State which the state machine should go to.
* @param data The data to be passed to the state machine.
*/
static void lwm2m_interface_internal_event(lwm2m_interface_t *interface, uint8_t, lwm2m_interface_event_data_u *event);
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static bool lwm2m_interface_is_bootstrap_waiting(lwm2m_interface_t *interface);
static bool lwm2m_interface_is_bootstrap_done(lwm2m_interface_t *interface);
static void lwm2m_interface_bootstrap_done(lwm2m_interface_t *interface);
static void lwm2m_interface_bootstrap_wait(lwm2m_interface_t *interface);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_client_registered(lwm2m_interface_t *interface);
static void lwm2m_interface_registration_updated(lwm2m_interface_t *interface);
static void lwm2m_interface_client_unregistered(lwm2m_interface_t *interface);
#if defined (MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP)
static void lwm2m_interface_client_ping(lwm2m_interface_t *interface);
#endif
static void lwm2m_interface_connection_handler(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code);
static void lwm2m_interface_registration_error(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code);
static void lwm2m_interface_state_bootstrap_or_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data, bool bootstrap);

static void lwm2m_interface_endpoint_event_handler(arm_event_t *event);

/**
* State enumeration order must match the order of state
* method entries in the state map
*/
enum E_States {
    STATE_IDLE = 0,
    STATE_BOOTSTRAP,
    STATE_BOOTSTRAP_ADDRESS_RESOLVED,
    STATE_BOOTSTRAP_RESOURCE_CREATED,
    STATE_BOOTSTRAP_WAIT,
    STATE_BOOTSTRAP_ERROR_WAIT, // 5
    STATE_BOOTSTRAPPED,
    STATE_REGISTER,
    STATE_REGISTER_ADDRESS_RESOLVED,
    STATE_REGISTERED,
    STATE_UPDATE_REGISTRATION, // 10
    STATE_UNREGISTER,
    STATE_UNREGISTERED,
    STATE_SENDING_COAP_DATA,
    STATE_COAP_DATA_SENT,
    STATE_COAP_DATA_RECEIVED, // 15
    STATE_PROCESSING_COAP_DATA,
    STATE_COAP_DATA_PROCESSED,
    STATE_WAITING,
    STATE_MAX_STATES
};

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_bootstrap_error(lwm2m_interface_t *interface, const char *reason);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_timer_expired(lwm2m_interface_t *interface, lwm2m_interface_timer_id_t type);

// state machine state functions

/**
* When the state is Idle.
*/
static void lwm2m_interface_state_idle(lwm2m_interface_t *interface, lwm2m_interface_event_data_u* data);

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
/**
* When the client starts bootstrap.
*/
static void lwm2m_interface_state_bootstrap(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the bootstrap server address is resolved.
*/
static void lwm2m_interface_state_bootstrap_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the bootstrap resource is created.
*/
static void lwm2m_interface_state_bootstrap_resource_created(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the server has sent response and bootstrapping is done.
*/
static void lwm2m_interface_state_bootstrapped(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

/**
* When the client starts register.
*/
static void lwm2m_interface_state_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the server address for register is resolved.
*/
static void lwm2m_interface_state_register_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client is registered.
*/
static void lwm2m_interface_state_registered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client is updating registration.
*/
static void lwm2m_interface_state_update_registration(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client starts unregister.
*/
static void lwm2m_interface_state_unregister(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client has been unregistered.
*/
static void lwm2m_interface_state_unregistered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap data is been sent through socket.
*/
static void lwm2m_interface_state_sending_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap data is sent successfully.
*/
static void lwm2m_interface_state_coap_data_sent(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the socket has received coap data.
*/
static void lwm2m_interface_state_coap_data_received(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap message is being processed.
*/
static void lwm2m_interface_state_processing_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the coap message has been processed.
*/
static void lwm2m_interface_state_coap_data_processed(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
* When the client is waiting to receive or send data.
*/
static void lwm2m_interface_state_waiting(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
 * Start registration update.
 */
static void lwm2m_interface_start_register_update(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data);

/**
 * @brief Redirects the state machine to right function.
 * @param current_state Current state to be set.
 * @param data Data to be passed to the state function.
 */
static void lwm2m_interface_state_function(lwm2m_interface_t *interface, lwm2m_interface_event_data_u* data);

/**
 * @brief State Engine maintaining state machine logic.
 */
static void lwm2m_interface_state_engine(lwm2m_interface_t *interface);

/**
* External event which can trigger the state machine.
* @param New The state to which the state machine should go.
* @param data The data to be passed to the state machine.
*/
static void lwm2m_interface_external_event(lwm2m_interface_t *interface, uint8_t, lwm2m_interface_event_data_u*);

/**
 * Helper method for extracting the IP address part and port from the
 * given server address.
 * @param interface Pointer to interface struct to store the address and port to.
 * @param server_address Source URL (depending on configuration, either without "coap" or "coaps" prefix, or as is).
 */
static void lwm2m_interface_process_address(lwm2m_interface_t *interface, const char* server_address);

/**
 * Helper method for storing the error description to _error_description if the feature
 * has not been turned off.
 * @param error description
 */
static void lwm2m_interface_set_error_description(lwm2m_interface_t *interface, const char *description);

static void lwm2m_interface_write_error_description(lwm2m_interface_t *interface, const char* reason, lwm2m_interface_error_t error_code);

static bool lwm2m_interface_create_endpoint(lwm2m_interface_t *interface,
                                        const char *type,
                                        const int32_t life_time,
                                        const int8_t event_handler_id);

static void lwm2m_interface_data_available(lwm2m_interface_t *interface, uint8_t* data,
                                    uint16_t data_size,
                                    const lwm2m_interface_socketaddress_t *address);

#if 0
static void lwm2m_interface_initialize_root_of_trust(void);
#endif

static void lwm2m_interface_connection_event_handler(connection_event_t event, void *impl, int error_code);

#define BEGIN_TRANSITION_MAP \
    static const uint8_t TRANSITIONS[] = {\

#define TRANSITION_MAP_ENTRY(entry)\
    entry,

#define END_TRANSITION_MAP(data) \
    0 };\
    lwm2m_interface_external_event(interface, TRANSITIONS[interface->current_state], data);

enum {
    EVENT_IGNORED = 0xFE,
    CANNOT_HAPPEN
};

static void lwm2m_interface_event_handler(arm_event_t *event)
{
    lwm2m_interface_t *interface = (lwm2m_interface_t*)event->data_ptr;
    tr_info("event_handler() event id: %" PRId8 " event_type: %" PRId8, event->event_id, event->event_type);

    if (event->event_id == ENDPOINT_EVENT_ID) {
        lwm2m_interface_endpoint_event_handler(event);
    } else if (event->event_id >= LWM2M_INTERFACE_TIMER_REGISTRATION && event->event_id <= LWM2M_INTERFACE_TIMER_REREGISTRATION) {
        lwm2m_interface_timer_expired(interface, (lwm2m_interface_timer_id_t) event->event_id);
    } else if (event->event_id == LWM2M_INTERFACE_EXTERNAL_EVENT) {
        lwm2m_interface_internal_event(interface, (uint8_t) event->event_data, &interface->external_event_data);
    } else if (event->event_id == CONNECTION_EVENT_ID) {
        lwm2m_interface_connection_event_handler((connection_event_t)event->event_type, interface, event->event_data);
    } else if (event->event_type == LWM2M_INTERFACE_EVENT_INIT) {
        // No need to do anything here.
    } else {
        tr_debug("event_handler() unknown event id");
    }
}

static void lwm2m_interface_endpoint_event_handler(arm_event_t *event)
{
    lwm2m_interface_t *interface = (lwm2m_interface_t*)event->data_ptr;
    switch (event->event_type) {
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

        case ENDPOINT_EVENT_BOOTSTRAP_SENT:

            // No need to do anything here.
            break;

        case ENDPOINT_EVENT_BOOTSTRAP_READY:

            tr_info("interface_event_handler ENDPOINT_EVENT_BOOTSTRAP_READY");

// At least BG96 modem does not send disconnect event(PEER CLOSE NOTIFY) when server closes the bootstrap connection.
// Call directy bootstrap done which triggers the mds registration.
#ifdef PROTOMAN_OFFLOAD_TLS
            // Clear the pending request flag since close notification does not arrive.
            //interface->endpoint.send_queue.pending = false;
            lwm2m_interface_bootstrap_done(interface);

#else
            lwm2m_interface_bootstrap_wait(interface);
#endif

            break;

        case ENDPOINT_EVENT_ERROR_BOOTSTRAP:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_BOOTSTRAP");
            lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_BOOTSTRAP_FAILED);
            break;

#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
        case ENDPOINT_EVENT_REGISTERED:

            tr_info("interface_event_handler ENDPOINT_EVENT_REGISTERED");
            lwm2m_interface_client_registered(interface);
            break;

        case ENDPOINT_EVENT_DEREGISTERED:

            tr_info("interface_event_handler ENDPOINT_EVENT_DEREGISTERED");
            req_handler_free_request_list(NULL, true, ERROR_NOT_REGISTERED);
            lwm2m_interface_client_unregistered(interface);
            break;

        case ENDPOINT_EVENT_REREGISTERED:
            lwm2m_interface_registration_updated(interface);
            tr_info("interface_event_handler ENDPOINT_EVENT_REREGISTERED");
            break;

        /* Error cases
            * TODO: Check if this error handling is correct for every cases. */

        case ENDPOINT_EVENT_ERROR_REREGISTER:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_REREGISTER");
            if (event->event_data == ENDPOINT_EVENT_STATUS_TIMEOUT) {
                lwm2m_interface_connection_handler(interface, LWM2M_INTERFACE_ERROR_NETWORK_ERROR);
            } else {
                // Fallback to full registration if update has failed
                interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_UNKNOWN_ERROR);
            }
            break;

        case ENDPOINT_EVENT_ERROR_REGISTER:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_REGISTER");
            if (event->event_data == ENDPOINT_EVENT_STATUS_TIMEOUT) {
                lwm2m_interface_connection_handler(interface, LWM2M_INTERFACE_ERROR_NETWORK_ERROR);
            } else if (event->event_data == ENDPOINT_EVENT_STATUS_NO_MEMORY) {
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_MEMORY_FAIL);
            }
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            else if (event->event_data == ENDPOINT_EVENT_STATUS_RESPONSE_FORBIDDEN ||
                       event->event_data == ENDPOINT_EVENT_STATUS_RESPONSE_BAD_REQUEST) {
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS);
            }
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            else {
                lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_NOT_REGISTERED);
            }
            break;

        case ENDPOINT_EVENT_ERROR_DEREGISTER:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_DEREGISTER");
            req_handler_free_request_list(NULL, true, ERROR_NOT_REGISTERED);
            lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_UNREGISTRATION_FAILED);
            break;

        case ENDPOINT_EVENT_ERROR_TIMEOUT:

            tr_warn("interface_event_handler ENDPOINT_EVENT_ERROR_NOTIFICATION_TIMEOUT");
            lwm2m_interface_connection_handler(interface, LWM2M_INTERFACE_ERROR_TIMEOUT);
            break;

        default:
            tr_error("interface_event_handler error: unknown event type");
            break;

    }
}

static void lwm2m_interface_connection_event_handler(connection_event_t event, void *impl, int error_code)
{
    lwm2m_interface_socketaddress_t address;
    lwm2m_interface_t *interface = (lwm2m_interface_t *)impl;
    uint8_t *data;
    size_t data_len = 0;

    switch(event) {

        case CONNECTION_EVENT_DATA:
            if (CONNECTION_STATUS_OK != connection_read_data(&interface->connection, &data, &data_len, (uint8_t **) &address.address, &address.length, &address.port)) {
                tr_warn("connection_event_handler connection_read_data failed");
                return;
            }
            address.stack = address.length == 4 ? LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV4 : LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV6;
            lwm2m_interface_data_available(interface, data, data_len, &address);
            break;

        case CONNECTION_EVENT_CONNECTED:

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            if (!lwm2m_interface_is_bootstrap_done(interface)) {
                tr_info("connection_event_handler - STATE_BOOTSTRAP_ADDRESS_RESOLVED");
                lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP_ADDRESS_RESOLVED, NULL);
            } else {
                tr_info("connection_event_handler - STATE_REGISTER_ADDRESS_RESOLVED");
                lwm2m_interface_internal_event(interface, STATE_REGISTER_ADDRESS_RESOLVED, NULL);
            }
#else
            tr_info("connection_event_handler - STATE_REGISTER_ADDRESS_RESOLVED");
            lwm2m_interface_internal_event(interface, STATE_REGISTER_ADDRESS_RESOLVED, NULL);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;

        case CONNECTION_EVENT_DISCONNECTED:

            tr_info("CONNECTION_EVENT_DISCONNECTED");
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            if (lwm2m_interface_is_bootstrap_waiting(interface)) {
                tr_info("connection_event_handler - CONNECTION_EVENT_DISCONNECTED");
                lwm2m_interface_bootstrap_done(interface);
            } else {
                lwm2m_interface_connection_handler(interface, lwm2m_interface_convert_protoman_to_client_error(error_code));
            }
#else
            lwm2m_interface_connection_handler(interface, lwm2m_interface_convert_protoman_to_client_error(error_code));
#endif
            break;
        case CONNECTION_EVENT_ERROR:

            tr_info("CONNECTION_EVENT_ERROR");
            lwm2m_interface_connection_handler(interface, lwm2m_interface_convert_protoman_to_client_error(error_code));
            break;

        case CONNECTION_EVENT_DESTROYED:
            tr_info("CONNECTION_EVENT_DESTROYED");
            break;

        case CONNECTION_EVENT_DATA_SENT:
            lwm2m_interface_data_sent(interface);
            break;

        case CONNECTION_EVENT_INTERFACE_STATUS:

            tr_info("CONNECTION_EVENT_INTERFACE_STATUS %d", error_code);

            if (!error_code && interface->reconnecting &&
                interface->reconnection_time > (uint32_t)(interface->initial_reconnection_time * 2) &&
                interface->endpoint.message_type == ENDPOINT_MSG_UNDEFINED) {

                // Resume is used here for restarting the reconnection pattern.
                // This is only done when reconnection time is on average shorter than it would be without this call.
                tr_info("Calling resume to reconnect");
                lwm2m_interface_resume(interface);

            } else {
                tr_info("Status change ignored");
            }

            break;

        default:

            break;

    }
}

#ifdef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
static int get_server_object_resources(endpoint_t *endpoint, register_resource_t **res)
{
    register_resource_t *curr;
    const char *binding_mode = NULL;

    curr = endpoint_create_register_resource_int(endpoint, lifetime_res_id, false, endpoint->lifetime);
    *res = curr;
    if (!curr) {
        return -1;
    }

    if (endpoint->mode == BINDING_MODE_Q) {
        binding_mode = BINDING_MODE_UDP_QUEUE;
    } else {
        binding_mode = BINDING_MODE_UDP;
    }
    curr->next = endpoint_create_register_resource_str(endpoint, binding_res_id, false, (uint8_t *)binding_mode, strlen(binding_mode));
    curr = curr->next;
    if (!curr) {
        return -1;
    }

    curr->next = endpoint_create_register_resource(endpoint, reg_update_res_id, false);
    curr = curr->next;
    if (!curr) {
        return -1;
    }

    return 0;
}
#endif

void lwm2m_interface_init(lwm2m_interface_t *interface,
                          const uint16_t listen_port,
                          oma_lwm2m_binding_and_mode_t mode,
                          lwm2m_interface_network_stack_t stack)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("init() -IN");
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->callback_handler = NULL;
#endif // MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->network_interface = NULL;
    interface->server_port = 0;
    interface->listen_port = listen_port;
    interface->current_state = STATE_IDLE;
    interface->binding_mode = mode;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
    interface->is_registered = false;
    interface->reconnecting = false;
    interface->retry_timer_expired = false;
    interface->bootstrapped = true; // True as default to get it working with connector only configuration
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->queue_mode_timer_ongoing = false;
#endif // #ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->unregister_ongoing = false;
    interface->event_ignored = false;
    interface->reconnect_attempt = 0;
    interface->event_handler_id = -1;
    interface->observer = NULL; // the lwm2m_interface_setup() will initialize the observation information
    interface->observer_id = -1;
    interface->observer_event.state = ARM_LIB_EVENT_UNQUEUED;
    interface->external_event.state = ARM_LIB_EVENT_UNQUEUED;
    interface->observer_event.allocator = ARM_LIB_EVENT_USER;
    interface->external_event.allocator = ARM_LIB_EVENT_USER;
    interface->initial_reconnection_time = 0;

    // Initializing internal protoman structure so that connection_close can be
    // called in any order.
    memset(&interface->connection.protoman, 0, sizeof(struct protoman_s));

    endpoint_init(&interface->endpoint,
                      &interface->connection,
                      (void *)interface,
                      (oma_lwm2m_binding_and_mode_t)(interface->binding_mode),
                      0);

#ifdef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
    // The server object won't handle any coap requests, but needs to be registered because of the res_cb
    object_handler_t *handler = endpoint_allocate_object_handler(M2M_SERVER_ID, get_server_object_resources, NULL, NULL);
    if (!handler) {
        tr_error("init() failed to allocate object handler");
        assert(handler); // if this happens it's a fatal error
        return;
    }
    endpoint_register_object_handler(&interface->endpoint, handler);
#endif
}

bool lwm2m_interface_setup(lwm2m_interface_t *interface,
                           int8_t observer_id,
                           void *observer,
                           const char *endpoint_type,
                           const int32_t life_time,
                           const char *context_address)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("setup()");

    if (event_handler_id < 0) {
        event_handler_id = eventOS_event_handler_create(lwm2m_interface_event_handler, LWM2M_INTERFACE_EVENT_INIT);
    }

    interface->event_handler_id = event_handler_id;

    if (interface->event_handler_id < 0) {
        tr_error("setup() eventOS_event_handler_create failed");
        return false;
    }

    interface->observer_id = observer_id;
    interface->observer = observer;

    //TODO:Increase the range from 1 to 100 seconds
    randLIB_seed_random();

    // Range is from 2 to 10
    interface->initial_reconnection_time = randLIB_get_random_in_range(2, 10);

    tr_info("init() initial random time %d\n", interface->initial_reconnection_time);
    interface->reconnection_time = interface->initial_reconnection_time;

    initialize_storage();

#if 0
    lwm2m_interface_initialize_root_of_trust();
#endif

    if(!lwm2m_interface_create_endpoint(interface,
                                        endpoint_type,
                                        life_time,
                                        interface->event_handler_id)) {

        tr_error("setup() create_endpoint failed");
        lwm2m_interface_clean(interface);

        return false;
    }

    return true;
}

#if 0
static void lwm2m_interface_initialize_root_of_trust(void)
{

    // RoT key size is 128 bits
    const size_t max_size = 128/8;
    uint8_t buffer[max_size];
    size_t real_size = 0;
    bool success = false;

    if (CCS_STATUS_SUCCESS == get_config_parameter(ROOT_OF_TRUST, buffer, max_size, &real_size)) {
        tr_info("initialize_root_of_trust() - read RoT from configuration, size %d", (int)real_size);
        success = true;
    }

    if (!success || real_size != max_size) {

        size_t len = 0;
#ifdef MBEDTLS_ENTROPY_HARDWARE_ALT
        // mbedtls can provide hardware-sourced random data if configured
        mbedtls_hardware_poll(NULL, (uint8_t *) &buffer, max_size, &len);

#elif MBED_CONF_MBED_CLOUD_CLIENT_USE_INSECURE_ROT
    #warning "You are using an insecure Root Of Trust implementation, DO NOT USE IN PRODUCTION ENVIRONMENTS. REPLACE WITH A PROPER IMPLEMENTATION BEFORE USE"
        tr_warn("initialize_root_of_trust() Using insecure implementation to generate Root of Trust");
        randLIB_get_n_bytes_random(&buffer, max_size);
        len = max_size;
#else
    #error "Please configure either a secure HW entropy source (MBEDTLS_ENTROPY_HARDWARE_ALT) or use insecure Root of Trust (MBED_CONF_MBED_CLIENT_USE_INSECURE_ROT) (NOT FOR PRODUCTION!)"
#endif

        if (len == max_size) {
            if (CCS_STATUS_SUCCESS != set_config_parameter(ROOT_OF_TRUST, buffer, max_size)) {
                tr_error("initialize_root_of_trust() failed to store new RoT");
            }
        } else {
            tr_error("initialize_root_of_trust() failed to generate new RoT");
        }
    }

    // don't leave the generated data to RAM
    memset(buffer, 0, max_size);
}
#endif

bool lwm2m_interface_create_endpoint(lwm2m_interface_t *interface,
                                     const char *type,
                                     const int32_t life_time,
                                     const int8_t event_handler_id)
{
    MBED_ASSERT(interface != NULL);

    tr_info("create_endpoint(type %s, lifetime %" PRId32 ", event_handler_id %" PRId8 ")",
            type, life_time, event_handler_id);

    if (endpoint_setup(&interface->endpoint, event_handler_id) != ENDPOINT_STATUS_OK) {
        return false;
    }

#ifndef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
    if (!lwm2m_interface_set_registration_update_cb(interface, lwm2m_interface_registration_update_cb)) {
        return false;
    }
#endif

    bool endpoint_correct = endpoint_set_parameters(&interface->endpoint, type, life_time);

    if (!endpoint_correct) {
        tr_error("create_endpoint() endpoint params are not valid");
    }

    return endpoint_correct;
}


bool lwm2m_interface_send_update_registration(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    return (ENDPOINT_STATUS_OK == endpoint_update_registration(&interface->endpoint));
}

void lwm2m_interface_set_cid_value(lwm2m_interface_t *interface, const uint8_t *data_ptr, const size_t data_len)
{
    MBED_ASSERT(interface != NULL);
    set_cid_value(&interface->connection, data_ptr, data_len);
}

#ifndef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
static registry_status_t lwm2m_interface_registration_update_cb(registry_callback_type_t cb_type,
                                                         const registry_path_t *path,
                                                         const registry_callback_token_t *cb_token,
                                                         const registry_object_value_t *value,
                                                         const registry_notification_status_t status,
                                                         registry_t *registry)
{

    // XXX: we could encapsulate this better. digging struct internals tends to lead into trouble later on.
    endpoint_t *endpoint = registry->notifier->endpoint;

    if (REGISTRY_CALLBACK_EXECUTE == cb_type) {

        if (ENDPOINT_STATUS_OK != endpoint_update_registration(endpoint)) {
            tr_error("registration_update_cb() failed to send update registration");
            return REGISTRY_STATUS_NO_MEMORY;
        }

        send_final_response(path, endpoint, cb_token->token, cb_token->token_size, COAP_MSG_CODE_RESPONSE_CHANGED, false);

    }

    return REGISTRY_STATUS_OK;
}

bool lwm2m_interface_set_registration_update_cb(lwm2m_interface_t *interface, registry_callback_t callback)
{
    registry_path_t path;

    MBED_ASSERT(interface != NULL);

    registry_set_path(&path, M2M_SERVER_ID, 0, SERVER_REGISTRATION_UPDATE, 0, REGISTRY_PATH_RESOURCE);
    if (registry_set_callback(&interface->endpoint.registry, &path, callback) != REGISTRY_STATUS_OK) {
        return false;
    }
    return true;
}
#endif

static void lwm2m_interface_stop_timers(const int8_t event_handler_id)
{

    // No need to call the cancellations if the tasklet is not even created.
    // This is the case typically when the init() has been called before, but not setup().
    if (event_handler_id < 0) {
        return;
    }

    // It does not matter that some of the calls fail here as it just means that the timer was not active.
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_RETRY, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW, event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REREGISTRATION, event_handler_id);

}

void lwm2m_interface_stop(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("stop() IN");

    lwm2m_interface_stop_timers(interface->event_handler_id);

    endpoint_stop(&interface->endpoint);
    connection_close(&interface->connection);

    tr_debug("stop() OUT");
}

void lwm2m_interface_pause(lwm2m_interface_t *interface)
{
    //MBED_ASSERT(interface != NULL);
    if (interface == NULL) {
        return;
    }

    tr_debug("pause() IN");

    lwm2m_interface_stop_timers(interface->event_handler_id);

    endpoint_stop(&interface->endpoint);

    connection_pause(&interface->connection);

    tr_debug("pause() OUT");
}

bool lwm2m_interface_resume(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

#ifdef MBED_CONF_CLOUD_CLIENT_USE_SOFT_PAUSE_RESUME
    tr_debug("resume() - soft, IN");
    if (connection_resume(&interface->connection)) {
        return true;
    } else {
        tr_debug("Couldn't soft resume, lwm2m_interface_resume() - IN");
    }
#endif

    // Trigger full reconnect
    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
    interface->reconnecting = false;
    interface->is_registered = false;
    interface->retry_timer_expired = false;
    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
#ifdef MBED_CONF_CLOUD_CLIENT_USE_SOFT_PAUSE_RESUME
    if (!lwm2m_interface_reset_timer(interface, LWM2M_INTERFACE_TIMER_RETRY, interface->event_handler_id, 0)) {
#else
    if (!lwm2m_interface_reset_timer(interface, LWM2M_INTERFACE_TIMER_RETRY, interface->event_handler_id, interface->reconnection_time * 1000)) {
#endif
        tr_error("lwm2m_interface_resume() lwm2m_interface_reset_timer Failed");
        return false;
    }

    tr_debug("resume() OUT");

    return true;

}

void lwm2m_interface_clean(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("clean() IN");

    lwm2m_interface_stop_timers(interface->event_handler_id);

    eventOS_cancel(&interface->observer_event);
    interface->observer = NULL;

    connection_destroy(&interface->connection);
    endpoint_destroy(&interface->endpoint);

    uninitialize_storage();

    tr_debug("clean() OUT");
}

void lwm2m_interface_bootstrap(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    tr_debug("bootstrap() IN");

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_RETRY, interface->event_handler_id);

    // Transition to a new state based upon
    // the current state of the state machine
    lwm2m_interface_event_data_u data;
    data.security_data.security_instance = 0;
    BEGIN_TRANSITION_MAP                                    // - Current State -
        TRANSITION_MAP_ENTRY (STATE_BOOTSTRAP)              // state_idle
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (STATE_BOOTSTRAP)              // state_bootstrapped
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_registered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_sending_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_sent
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_received
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_processing_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_processed
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_waiting
    END_TRANSITION_MAP(&data)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        lwm2m_interface_set_error_description(interface, ERROR_REASON_2);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
    tr_debug("bootstrap() OUT");
#else
    lwm2m_interface_set_error_description(interface, ERROR_REASON_3);
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
}

void lwm2m_interface_cancel_bootstrap(lwm2m_interface_t *interface)
{
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
//TODO: Do we need this ?
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
}

void lwm2m_interface_register_object(lwm2m_interface_t *interface, uint16_t security_instance)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("register_object IN");
    // TODO: check that the security object instance exists
    if(false) {
        lwm2m_interface_set_error_description(interface, ERROR_REASON_4);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS);
        return;
    }
    // Transition to a new state based upon
    // the current state of the state machine
    lwm2m_interface_event_data_u data;
    data.security_data.security_instance = 0; //security;

    BEGIN_TRANSITION_MAP                                    // - Current State -
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_idle
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_bootstrapped
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_registered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_sending_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_sent
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_received
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_processing_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_processed
        TRANSITION_MAP_ENTRY (STATE_REGISTER)               // state_waiting
    END_TRANSITION_MAP(&data)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        lwm2m_interface_set_error_description(interface, ERROR_REASON_5);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
    tr_debug("register_object OUT");
}

void lwm2m_interface_update_registration(lwm2m_interface_t *interface, uint16_t security_instance, const uint32_t lifetime)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("update_registration()");
    lwm2m_interface_event_data_u data;
    data.update_register_data.security_instance = security_instance;
    data.update_register_data.lifetime = lifetime;
    lwm2m_interface_start_register_update(interface, &data);
}

void lwm2m_interface_unregister_object(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("unregister_object - current state %d", interface->current_state);
    // Transition to a new state based upon
    // the current state of the state machine
    BEGIN_TRANSITION_MAP                                // - Current State -
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_idle
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_bootstrapped
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_register
        TRANSITION_MAP_ENTRY (STATE_UNREGISTERED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_registered
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_sending_coap_data
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_coap_data_sent
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_coap_data_received
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_processing_coap_data
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_coap_data_processed
        TRANSITION_MAP_ENTRY (STATE_UNREGISTER)             // state_waiting
    END_TRANSITION_MAP(NULL)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        lwm2m_interface_set_error_description(interface, ERROR_REASON_6);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
    tr_debug("unregister_object OUT");
}

#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
void lwm2m_interface_set_queue_sleep_handler(lwm2m_interface_t *interface, interface_callback_handler handler)
{
    MBED_ASSERT(interface != NULL);
    interface->callback_handler = handler;
}
#endif //#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE

void lwm2m_interface_set_random_number_callback(lwm2m_interface_t *interface, random_number_cb callback)
{
    // XXX: what was the old thing doing?
}
#ifndef PROTOMAN_OFFLOAD_TLS
void lwm2m_interface_set_entropy_callback(lwm2m_interface_t *interface, entropy_cb callback)
{
    MBED_ASSERT(interface != NULL);

    if (connection_set_entropy_callback(&interface->connection, callback) < 0) {
        tr_error("set_entropy_callback() failed to add entropy source");
    }
}
#endif // PROTOMAN_OFFLOAD_TLS

void lwm2m_interface_set_platform_network_handler(lwm2m_interface_t *interface, void *handler)
{
    MBED_ASSERT(interface != NULL);

    interface->network_interface = handler;
}

static void lwm2m_interface_client_registered(lwm2m_interface_t *interface)
{
    tr_info("client_registered");
    interface->is_registered = true;
    lwm2m_interface_internal_event(interface, STATE_REGISTERED, NULL);

#if defined(MBED_CLOUD_CLIENT_FOTA_ENABLE) && !defined(MBED_CLOUD_FOTA_CUSTOM_RESUME)
    fota_internal_resume();
#endif

    // Inform client is registered.
    // TODO: use server id as parameter?
    // TODO: check if above registration process goes to unregistration flow. Then this should not be called at all.
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_OBJECT_REGISTERED, LWM2M_INTERFACE_ERROR_NONE);
}

static void lwm2m_interface_registration_updated(lwm2m_interface_t *interface)
{
    tr_info("registration_updated");
    interface->is_registered = true;
    lwm2m_interface_internal_event(interface, STATE_REGISTERED, NULL);
#if defined(MBED_CLOUD_CLIENT_FOTA_ENABLE) && !defined(MBED_CLOUD_FOTA_CUSTOM_RESUME)
    fota_internal_resume();
#endif
    // TODO: use server id as parameter?
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_REGISTRATION_UPDATED, LWM2M_INTERFACE_ERROR_NONE);
}

static void lwm2m_interface_registration_error(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code)
{
    tr_error("registration_error code [%d]", error_code);
    interface->is_registered = false;
    endpoint_stop(&interface->endpoint);

    // Try to register again
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    interface->queue_mode_timer_ongoing = false;
#endif //#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    if (error_code == LWM2M_INTERFACE_ERROR_UNREGISTRATION_FAILED) {

        interface->unregister_ongoing = false;
        interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION;
    }
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
else if (error_code == LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS) {
        storage_clear_credentials(&interface->endpoint.registry);
        interface->bootstrapped = false;
    }
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    else if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE) {

        // If update registration failed again try full registration right away
        tr_info("Update registration retry failed, try full registration right away");
        interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_FULL_REGISTRATION;
        if(ENDPOINT_STATUS_OK != endpoint_register(&interface->endpoint)) {
            // If resource creation fails then inform error to application
            tr_error("registration_error endpoint_register: LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
            error_code = LWM2M_INTERFACE_ERROR_NOT_ALLOWED;
        } else {
            return;
        }
    }

    lwm2m_interface_connection_handler(interface, error_code);
}

static void lwm2m_interface_client_unregistered(lwm2m_interface_t *interface)
{
    tr_info("client_unregistered()");
    interface->unregister_ongoing = false;
    interface->is_registered = false;
    lwm2m_interface_internal_event(interface, STATE_UNREGISTERED, NULL);
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_OBJECT_UNREGISTERED, LWM2M_INTERFACE_ERROR_NONE);
}

#if defined (MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP)
static void lwm2m_interface_client_ping(lwm2m_interface_t *interface)
{
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_CLIENT_PING;
}
#endif

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_bootstrap_done(lwm2m_interface_t *interface)
{
    registry_path_t path;
    bool bootstrap;

    tr_info("bootstrap_done");

    registry_set_path(&path, M2M_SECURITY_ID, 0, SECURITY_BOOTSTRAP_SERVER, 0, REGISTRY_PATH_RESOURCE);
    if (REGISTRY_STATUS_OK != registry_get_value_boolean(&interface->endpoint.registry, &path, &bootstrap)) {
        lwm2m_interface_bootstrap_error(interface, ERROR_REASON_12);
        return;
    }

    if (bootstrap) {
        if (!storage_set_bootstrap_credentials(&interface->endpoint.registry)) {
            lwm2m_interface_bootstrap_error(interface, ERROR_REASON_12);
            return;
        }
        lwm2m_interface_bootstrap(interface);
        return;
    }

    if (!storage_set_credentials(&interface->endpoint.registry)) {
        lwm2m_interface_bootstrap_error(interface, ERROR_REASON_26);
        return;
    }

    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnecting = false;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
    interface->bootstrapped = true;

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);

    lwm2m_interface_internal_event(interface, STATE_BOOTSTRAPPED, NULL);

    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_BOOTSTRAP_DONE, LWM2M_INTERFACE_ERROR_NONE);

}

static void lwm2m_interface_bootstrap_wait(lwm2m_interface_t *interface)
{

    tr_info("bootstrap_wait");
    lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP_WAIT, NULL);
}

static void lwm2m_interface_bootstrap_error(lwm2m_interface_t *interface, const char *reason)
{

    tr_error("bootstrap_error(%s)", reason);
    interface->bootstrapped = false;

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);
    connection_close(&interface->connection);

    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;

    lwm2m_interface_set_error_description(interface, reason);

    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_BOOTSTRAP_FAILED);

    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
    interface->reconnecting = true;

    interface->retry_timer_expired = false;
    lwm2m_interface_reset_timer(interface,
                                LWM2M_INTERFACE_TIMER_RETRY,
                                interface->event_handler_id,
                                interface->reconnection_time * 1000);

    tr_info("bootstrap_error - reconnecting in %" PRIu32 "(s)", interface->reconnection_time);
    interface->reconnection_time = interface->reconnection_time * RECONNECT_INCREMENT_FACTOR;
    if(interface->reconnection_time >= MAX_RECONNECT_TIMEOUT) {
        interface->reconnection_time = MAX_RECONNECT_TIMEOUT;
    }

}
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_data_available(lwm2m_interface_t *interface,
                                    uint8_t* data,
                                    uint16_t data_size,
                                    const lwm2m_interface_socketaddress_t *address)
{
    tr_debug("data_available");
    lwm2m_interface_event_data_u event;
    event.received_data.data = data;
    event.received_data.size = data_size;
    event.received_data.address = address;
    lwm2m_interface_internal_event(interface, STATE_COAP_DATA_RECEIVED, &event);
}

static void lwm2m_interface_connection_handler(lwm2m_interface_t *interface, lwm2m_interface_error_t error_code)
{

    endpoint_stop(&interface->endpoint);
    connection_close(&interface->connection);
    if (interface->current_state == STATE_BOOTSTRAP_WAIT) {
        tr_debug("connection_handler() bootstrap completed");
       // Bootstrap completed once PEER CLOSE notify received from the server.
       return;
    }

    tr_error("connection_handler: (%d), reconnecting (%d), reconnection_state (%d)",
            error_code, interface->reconnecting, (int)interface->reconnection_state);

#if defined (MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP)
    if ((interface->binding_mode == BINDING_MODE_U || interface->binding_mode == BINDING_MODE_Q) &&
         error_code == LWM2M_INTERFACE_ERROR_NETWORK_ERROR && is_connection_id_available()) {
        // Check if we can ping LWm2m server (send it immediately and lets have timeout of 60 seconds)
        //   if(server responds)
        //       CID has expired, delete CID do handshake
        //   else
        //        Network issue, do not delete CID but continue reconnection logic (99%)
        lwm2m_interface_client_ping(interface);
        return;
    }
#endif //MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW, interface->event_handler_id);
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);

    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);

    // Try to do reconnecting
    if (interface->reconnecting) {
        // If reconnecting has already failed, try lower level of reconnection if possible.
        if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_FULL_REGISTRATION) {
            interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
        } else if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION) {
            tr_info("connection_handler - unreg failed again just call client_unregistered");
            lwm2m_interface_client_unregistered(interface);
            return;
        }
    }
    interface->reconnecting = true;
    interface->retry_timer_expired = false;
    lwm2m_interface_reset_timer(interface,
                                LWM2M_INTERFACE_TIMER_RETRY,
                                interface->event_handler_id,
                                interface->reconnection_time * 1000);

    tr_info("connection_handler - reconnecting in %" PRIu32 "(s)", interface->reconnection_time);
    interface->reconnection_time = interface->reconnection_time * RECONNECT_INCREMENT_FACTOR;
    if (interface->reconnection_time >= MAX_RECONNECT_TIMEOUT) {
        interface->reconnection_time = MAX_RECONNECT_TIMEOUT;
    }

        lwm2m_interface_write_error_description(interface, ERROR_REASON_9, error_code);
    // Inform application after trying reconnection for MAX_RECONNECT_ATTEMPT times.
    if (interface->reconnect_attempt >= MAX_RECONNECT_ATTEMPT) {
        interface->reconnect_attempt = 0;
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, error_code);
    }
}

void lwm2m_interface_data_sent(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    tr_debug("data_sent()");

#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    if (lwm2m_interface_queue_mode(interface) && interface->callback_handler) {

        if (interface->callback_handler && (interface->unregister_ongoing == false)) {

            lwm2m_interface_reset_timer(interface,
                                        LWM2M_INTERFACE_TIMER_QUEUE_SLEEP,
                                        interface->event_handler_id,
                                        MBED_CLIENT_RECONNECTION_COUNT*MBED_CLIENT_RECONNECTION_INTERVAL*1000*2);
        }
    }
#endif // #ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    if (interface->current_state == STATE_BOOTSTRAP_ERROR_WAIT) {
        // bootstrap_error to be called only after we have sent the last ACK.
        // Otherwise client will goto reconnection mode before ACK has sent.
        lwm2m_interface_bootstrap_error(interface, lwm2m_interface_error_description(interface));
    } else if (interface->current_state != STATE_BOOTSTRAP_WAIT) {
        lwm2m_interface_internal_event(interface, STATE_COAP_DATA_SENT, NULL);
    }
#else
    lwm2m_interface_internal_event(interface, STATE_COAP_DATA_SENT, NULL);
#endif // MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
}

static void lwm2m_interface_timer_expired(lwm2m_interface_t *interface, lwm2m_interface_timer_id_t type)
{
    if (LWM2M_INTERFACE_TIMER_REREGISTRATION == type) {
        lwm2m_interface_internal_event(interface, STATE_UPDATE_REGISTRATION, NULL);
    }
    else if (LWM2M_INTERFACE_TIMER_RETRY == type) {

        if (interface->reconnecting) {
            tr_debug("timer_expired() - retry");
            interface->reconnect_attempt++;
            interface->retry_timer_expired = true;
        }

        lwm2m_interface_event_data_u data;
        data.security_data.security_instance = 0;
        if (interface->bootstrapped) {
            lwm2m_interface_internal_event(interface, STATE_REGISTER, &data);
        } else {
            lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP, &data);
        }
    }
    else if (LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW == type) {
#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
        tr_debug("timer_expired() - bootstrap");
        interface->bootstrapped = false;
        eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW, interface->event_handler_id);
        lwm2m_interface_bootstrap_error(interface, ERROR_REASON_23);
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    }
    else if (LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW == type) {
        tr_debug("timer_expired() - register");
        lwm2m_interface_registration_error(interface, LWM2M_INTERFACE_ERROR_TIMEOUT);
    }
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    else if(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP == type) {
        uint_fast16_t queue_size = 0;
#ifdef ENABLE_RESENDINGS
        queue_size = ns_list_count(&interface->endpoint.coap->linked_list_resent_msgs);
#endif
        if (queue_size > 0 || !interface->is_registered || interface->reconnecting || !interface->bootstrapped) {

            tr_debug("timer_expired() - RESEND queue not empty, or not registered, or reconnection or bootstrap ongoing, continue sleep timer");
            lwm2m_interface_reset_timer(interface,
                                        LWM2M_INTERFACE_TIMER_QUEUE_SLEEP,
                                        interface->event_handler_id,
                                        MBED_CLIENT_RECONNECTION_COUNT * MBED_CLIENT_RECONNECTION_INTERVAL * 1000);

        } else {
            tr_debug("timer_expired() - sleep");
            //TODO: Check if more actions needed here?
            interface->queue_mode_timer_ongoing = true;
            if(interface->callback_handler) {
                interface->callback_handler(interface->observer);
            }
        }
    }
#endif // MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
}

// state machine sits here.
static void lwm2m_interface_state_idle(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_idle");
    interface->unregister_ongoing = false; //TODO Check if this set should be done here?
    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_QUEUE_SLEEP, interface->event_handler_id);
}

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_state_bootstrap(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data) {
    lwm2m_interface_state_bootstrap_or_register(interface, data, true);
}
#endif

static void lwm2m_interface_state_bootstrap_or_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data, bool bootstrap)
{

    lwm2m_interface_error_t error = LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS;
    int64_t security_mode =  LWM2M_INTERFACE_SECURITY_MODE_PSK;
    char full_server_address[MAX_VALUE_LENGTH];
    int32_t full_server_address_size = MAX_VALUE_LENGTH - 1;
    char *server_address = NULL;
    char *full_server_address_end;
    bool security_available = false;
    const void *certificate = NULL;
    size_t certificate_size = 0;
    const void *key = NULL;
    size_t key_size = 0;
    const void *ca_certificate = NULL;
    size_t ca_certificate_size = 0;
    interface->is_registered = false;
#ifdef PROTOMAN_USE_SSL_SESSION_RESUME
    bool ignore_session_resume = interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_CLIENT_PING;
    if (ignore_session_resume) {
        if (interface->is_registered) {
            interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
        } else {
            interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
        }
    }
#endif

    tr_debug("state_bootstrap_or_register() in %s sequence", (bootstrap ? "bootstrap" : "register"));

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
    if (bootstrap) {
        interface->bootstrapped = false;
    } else
#endif
    {
        interface->listen_port = 0;
#ifndef MBED_CLOUD_CLIENT_DISABLE_REGISTRY
        storage_set_credentials(&interface->endpoint.registry);
#endif
    }

    full_server_address_end = storage_read_uri(full_server_address, &full_server_address_size, bootstrap);
    *full_server_address_end = '\0';

    if (strlen(full_server_address)) {
        tr_debug("state_bootstrap_or_register - server_address %s", full_server_address);

#ifndef MBED_CLIENT_ENABLE_MINIMAL_SERVER_URL_PROCESSING
        if (strstr(full_server_address, COAP)) {
            server_address = full_server_address + strlen(COAP);
            security_mode = LWM2M_INTERFACE_SECURITY_MODE_NO_SECURITY;
        }
        else if (strstr(full_server_address, COAPS)) {
            server_address = full_server_address + strlen(COAPS);
        }
#else
        // Don't strip protocol string
        server_address = full_server_address;
#endif
        if (server_address == NULL) {
            tr_error("No valid server address available");
            goto finish;
        }
        lwm2m_interface_process_address(interface, server_address);

        uint8_t connection_mode = CONNECTION_MODE_UDP;
#if defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP_QUEUE)
        if (interface->binding_mode == BINDING_MODE_T_Q || interface->binding_mode == BINDING_MODE_T) {
            connection_mode = CONNECTION_MODE_TCP;
        }
#endif

        tr_debug("state_bootstrap_or_register - IP address %s , Port %d", interface->server_ip_address, interface->server_port);
        // If bind and resolving server address succeed then proceed else
        // return error to the application and go to Idle state.
        if(strlen(interface->server_ip_address) != 0) {

            lwm2m_interface_reset_timer(interface,
                                        bootstrap ? LWM2M_INTERFACE_TIMER_BOOTSTRAP_FLOW : LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW,
                                        interface->event_handler_id,
                                        MBED_CLIENT_RECONNECTION_COUNT * MBED_CLIENT_RECONNECTION_INTERVAL * 8 * 1000);

            if (security_mode != LWM2M_INTERFACE_SECURITY_MODE_NO_SECURITY) {

                connection_mode |= CONNECTION_MODE_FLAG_SECURE;
#ifdef PROTOMAN_SECURITY_ENABLE_CERTIFICATE

#ifdef PROTOMAN_OFFLOAD_TLS
                security_available = true;
#else
                certificate = storage_read_certificate(&certificate_size, bootstrap);
                key = storage_read_certificate_key(&key_size, bootstrap);
                ca_certificate = storage_read_ca_certificate(&ca_certificate_size, bootstrap);

                if (certificate && key && ca_certificate) {
                    security_available = true;
                }
#endif

#elif defined(PROTOMAN_SECURITY_ENABLE_PSK)

                size_t size;
                size = sizeof(interface->psk);
                security_available = storage_read_psk(interface->psk, &size, bootstrap);
                interface->psk_size = size;

                if (security_available) {
                    size = sizeof(interface->psk_id);
                    security_available = storage_read_psk_id(interface->psk_id, &size, bootstrap);
                    interface->psk_id_size = size;
                }

                if (security_available) {

                    certificate = interface->psk_id;
                    certificate_size = interface->psk_id_size;
                    key = interface->psk;
                    key_size = interface->psk_size;

                }

#endif
            }

            if (security_available || security_mode == LWM2M_INTERFACE_SECURITY_MODE_NO_SECURITY) {

                connection_close(&interface->connection);

                if (CONNECTION_STATUS_OK == connection_init(&interface->connection, &lwm2m_interface_connection_event_handler,interface->event_handler_id , interface, interface->server_ip_address, interface->server_port,
                                                            connection_mode, interface->network_interface,
                                                            ca_certificate, ca_certificate_size, certificate,
                                                            certificate_size, key, key_size
#if defined(PROTOMAN_USE_SSL_SESSION_RESUME) || defined(PROTOMAN_OFFLOAD_TLS)
                                                            , bootstrap
#endif
#ifdef PROTOMAN_USE_SSL_SESSION_RESUME
                                                            , ignore_session_resume
#endif
                                                            )) {
                    error = LWM2M_INTERFACE_ERROR_NONE;
                    connection_start(&interface->connection);
                }

            }

        }
    }

finish:
    // XXX: still needed? fast fail could be easier to pull off if this were a function.
    if (error != LWM2M_INTERFACE_ERROR_NONE) {
        tr_error("state_bootstrap_or_register : INVALID_PARAMETERS");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_11);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, error);
    }

}

#ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
static void lwm2m_interface_state_bootstrap_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    (void)data;

    tr_debug("state_bootstrap_address_resolved()");

    if(ENDPOINT_STATUS_OK == endpoint_bootstrap(&interface->endpoint)) {
       lwm2m_interface_internal_event(interface, STATE_BOOTSTRAP_RESOURCE_CREATED, NULL);
    } else{
        // If resource creation fails then inform error to application
        tr_error("state_bootstrap_address_resolved : ERROR_NOT_ALLOWED");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_12);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
    }
}

static void lwm2m_interface_state_bootstrap_resource_created(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_bootstrap_resource_created");
}

static void lwm2m_interface_state_bootstrapped(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_bootstrapped");
    connection_close(&interface->connection);
}
#endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE

static void lwm2m_interface_state_register(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_register");
    lwm2m_interface_state_bootstrap_or_register(interface, data, false);
}

static void lwm2m_interface_process_address(lwm2m_interface_t *interface, const char *server_address)
{
#ifndef MBED_CLIENT_ENABLE_MINIMAL_SERVER_URL_PROCESSING
    memset(interface->server_ip_address, 0 ,MAX_ALLOWED_IP_STRING_LENGTH);
    const char* colon = strrchr(server_address, ':');
    if (!colon) {
        return;
    }

    int colonFound = colon - server_address + 1;
    if(colonFound > 0) {
        memcpy(interface->server_ip_address, server_address, strlen(server_address) - strlen(colon));
        colon += 1;
        interface->server_port = atoi(colon);
        const char* end = strrchr(interface->server_ip_address, ']');
        if (end) {
            colonFound = end - interface->server_ip_address + 1;
            if(strncmp(interface->server_ip_address, "[", 1) == 0) {
                if(colonFound < 0) {
                    memset(interface->server_ip_address, 0, MAX_ALLOWED_IP_STRING_LENGTH);
                } else {
                    memmove(interface->server_ip_address, interface->server_ip_address+1, colonFound-1);
                    interface->server_ip_address[colonFound] = '\0';
                }
            } else if(colonFound > 0) {
                memset(interface->server_ip_address, 0, MAX_ALLOWED_IP_STRING_LENGTH);
            }
        }
    }
#else
    // Exclude aid parameter from string if it's present
    char *tmp_ptr = strchr(server_address, '?');
    if (tmp_ptr) {
        *tmp_ptr = '\0';
    }
    // Copy the address to the interface's buffer
    const size_t server_address_len = strlen(server_address) + 1;
    if (sizeof(interface->server_ip_address) >= server_address_len) {
        memcpy(interface->server_ip_address, server_address, server_address_len);
    } else {
        assert(false);
        interface->server_ip_address[0] = '\0';
    }
    // Ignore port - the underlying network stack can try parse it from the address if it wants to
    interface->server_port = 0;
#endif
}

bool lwm2m_interface_queue_mode(const lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    if((interface->binding_mode == BINDING_MODE_Q)
#if defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP) || defined(MBED_CLOUD_CLIENT_TRANSPORT_MODE_TCP_QUEUE)
       || (interface->binding_mode == BINDING_MODE_T_Q)
#endif
       ) {
        return true;
    }
    return false;
}

static void lwm2m_interface_state_register_address_resolved(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    uint8_t *address;
    uint8_t address_len;
    uint16_t port;

    (void)data;

    tr_debug("state_register_address_resolved");

    connection_get_server_address(&interface->connection, &address, &address_len, &port);

    tr_info("state_register_address_resolved : IPv%d address", ((address_len == 4) ? 4 : 6));

    switch (interface->reconnection_state) {
        case LWM2M_INTERFACE_RECONNECTION_STATE_NONE:
        case LWM2M_INTERFACE_RECONNECTION_STATE_FULL_REGISTRATION:
            if(ENDPOINT_STATUS_OK != endpoint_register(&interface->endpoint)) {
                // If resource creation fails then inform error to application
                tr_error("state_register_address_resolved : LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
                lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
                lwm2m_interface_set_error_description(interface, ERROR_REASON_25);
                lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
            }
            break;
        case LWM2M_INTERFACE_RECONNECTION_STATE_CLIENT_PING:
            break;
        case LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE:
            // Start registration update in case it is reconnection logic because of network issue.
            lwm2m_interface_internal_event(interface, STATE_UPDATE_REGISTRATION, NULL);
            break;
        case LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION:
            lwm2m_interface_internal_event(interface, STATE_UNREGISTER, NULL);
            break;
    }

}

static void lwm2m_interface_state_registered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    uint32_t lifetime = MINIMUM_REGISTRATION_TIME;
    uint16_t registration_percent = REREGISTRATION_INTERVAL;

    tr_info("state_registered");

    eventOS_event_timer_cancel(LWM2M_INTERFACE_TIMER_REGISTRATION_FLOW, interface->event_handler_id);

    if (ENDPOINT_STATUS_OK == endpoint_get_lifetime(&interface->endpoint, &lifetime)) {


        // If it is a UDP or UDP_QUEUE mode, we need to scale down the registration update time based
        // on lifetime values,
        // Lifetime values upto 300 seconds , registration update should be triggered at 50% of lapsed lifetime
        // Lifetime values upto 600 seconds , registration update should be triggered at 60% of lapsed lifetime
        // Lifetime values more than 600 seconds , registration update should be triggered at 70% of lapsed
        // lifetime like normal registration update
        if (interface->binding_mode == BINDING_MODE_U ||
            interface->binding_mode == (BINDING_MODE_U | BINDING_MODE_Q)) {
            if (lifetime <= 300) {
                registration_percent = REREGISTRATION_UDP_QUEUE_LOW_INTERVAL;
            } else if (lifetime <= 600) {
                registration_percent = REREGISTRATION_UDP_QUEUE_INTERMEDIATE_INTERVAL;
            }
        }

        if (lifetime < MINIMUM_REGISTRATION_TIME) {
            lifetime = MINIMUM_REGISTRATION_TIME;
        }

#ifdef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
        // If bootstrap is disabled internal endpoint name isn't available other than if parsed from the
        // location path of the registration response message. Parse and store it here.
        const char *iep = interface->endpoint.location;
        int count = 0;

        // Find the string following the second "/" character in the endpoint location-path
        // The format should be "rd/<aid>/<iep>"
        while ((iep = strstr(iep, "/")) != NULL) {
            iep++;
            if (++count == 2) {
                break;
            }
        }

        if (iep && strlen(iep) > 0) {
            if (!storage_set_internal_endpoint_name(iep)) {
                tr_error("state_registered() error storing internal endpoint name");
            }
        } else {
            tr_error("state_registered() failed to parse internal endpoint name");
        }

#endif
    } else {
        tr_error("state_registered() error reading endpoint lifetime");
    }

    lwm2m_interface_reset_timer(interface,
                                LWM2M_INTERFACE_TIMER_REREGISTRATION,
                                interface->event_handler_id,
                                lifetime * 10 * registration_percent);

    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnecting = false;

    // Continue with the unregistration process if it has failed due to connection lost
    if (interface->reconnection_state == LWM2M_INTERFACE_RECONNECTION_STATE_UNREGISTRATION) {
        lwm2m_interface_internal_event(interface, STATE_UNREGISTER, NULL);
    } else {
        interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
    }
}

static void lwm2m_interface_state_update_registration(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_update_registration");
#ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE
    // Set to false to allow reconnection to work.
    interface->queue_mode_timer_ongoing = false;
#endif // #ifdef MBED_CLOUD_CLIENT_TRANSPORT_MODE_UDP_QUEUE

    if (data) {

        uint32_t new_lifetime = data->update_register_data.lifetime;

        endpoint_set_lifetime(&interface->endpoint, new_lifetime);

    } else {
        tr_debug("state_update_registration no event data found");
    }

    if (ENDPOINT_STATUS_OK != endpoint_update_registration(&interface->endpoint)) {

        tr_error("state_update_registration : LWM2M_INTERFACE_ERROR_MEMORY_FAIL");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_25);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);

    }
}

static void lwm2m_interface_state_unregister(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_unregister");
    if (interface->unregister_ongoing) {
        tr_warn("state_unregister : _unregister_ongoing");
        return;
    }
    lwm2m_interface_internal_event(interface, STATE_SENDING_COAP_DATA, NULL);
    if (ENDPOINT_STATUS_OK != endpoint_unregister(&interface->endpoint)) {
        tr_error("state_unregister : LWM2M_INTERFACE_ERROR_NOT_ALLOWED");
        lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
        lwm2m_interface_set_error_description(interface, ERROR_REASON_5);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
        return;
    }
    interface->unregister_ongoing = true;
}

static void lwm2m_interface_state_unregistered(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_info("state_unregistered");
    interface->reconnection_time = interface->initial_reconnection_time;
    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_NONE;
    connection_close(&interface->connection);
    lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_OBJECT_UNREGISTERED, LWM2M_INTERFACE_ERROR_NONE);
    lwm2m_interface_internal_event(interface, STATE_IDLE, NULL);
}

static void lwm2m_interface_state_sending_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    //NOTE: This function is no-longer used.
    tr_debug("state_sending_coap_data");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_coap_data_sent(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_coap_data_sent");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_coap_data_received(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{

    tr_debug("state_coap_data_received");

    if(data) {
        lwm2m_interface_received_data_t event = data->received_data;

        sn_nsdl_addr_s address;

        lwm2m_interface_network_stack_t stack = event.address->stack;

        if(LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV4 == stack) {
            address.type = SN_NSDL_ADDRESS_TYPE_IPV4;
            address.addr_len = 4;
        } else if((LWM2M_INTERFACE_NETWORK_STACK_LWIP_IPV6 == stack) ||
                  (LWM2M_INTERFACE_NETWORK_STACK_NANOSTACK_IPV6 == stack)) {
            address.type = SN_NSDL_ADDRESS_TYPE_IPV6;
            address.addr_len = 16;
        }
        address.port = event.address->port;
        address.addr_ptr = (uint8_t*)event.address->address;
        address.addr_len = event.address->length;

        // Process received data
        lwm2m_interface_internal_event(interface, STATE_PROCESSING_COAP_DATA, NULL);
        if(ENDPOINT_STATUS_OK != endpoint_process_coap(&interface->endpoint, event.data, event.size, &address)) {
           tr_error("state_coap_data_received : LWM2M_INTERFACE_ERROR_RESPONSE_PARSE_FAILED");
           lwm2m_interface_set_error_description(interface, ERROR_REASON_17);
           lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_RESPONSE_PARSE_FAILED);

// With BG96 first message(BS POST) is corrupted and queue flag is not automatically cleared.
// Let's do it here as a workaround otherwise first try against mds will lead to reconnection.
#ifdef PROTOMAN_OFFLOAD_TLS
           interface->endpoint.send_queue.sending_in_progress = false;
#endif
        }
        lwm2m_free(event.data);
    }

}

static void lwm2m_interface_state_processing_coap_data(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_processing_coap_data");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_coap_data_processed(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_coap_data_processed");
    lwm2m_interface_internal_event(interface, STATE_WAITING, NULL);
}

static void lwm2m_interface_state_waiting(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data)
{
    tr_debug("state_waiting");
}

// generates an external event. called once per external event
// to start the state machine executing
static void lwm2m_interface_external_event(lwm2m_interface_t *interface,
                                    uint8_t new_state,
                                    lwm2m_interface_event_data_u* p_data)
{
    tr_debug("external_event : new state %d", new_state);
    // if we are supposed to ignore this event
    if (new_state == EVENT_IGNORED) {
        tr_debug("external_event : new state is EVENT_IGNORED");
        interface->event_ignored = true;
    }
    else {
        tr_debug("external_event : handle new state");

        eventOS_cancel(&interface->external_event);

        // we generate a preallocated event, which will be handled by lwm2m_interface_external_event_handler()
        interface->external_event.data.event_data = new_state;
        interface->external_event.data.data_ptr = interface;
        interface->external_event.data.receiver = interface->event_handler_id;
        interface->external_event.data.sender = 0;
        interface->external_event.data.event_id = LWM2M_INTERFACE_EXTERNAL_EVENT;
        interface->external_event.data.priority = ARM_LIB_LOW_PRIORITY_EVENT;
        interface->external_event.data.event_type = 0;
        if (p_data) {
            interface->external_event_data = *p_data;
        }

        eventOS_event_send_user_allocated(&interface->external_event);
    }
}

// generates an internal event. called from within a state
// function to transition to a new state
static void lwm2m_interface_internal_event(lwm2m_interface_t *interface,
                                    uint8_t new_state,
                                    lwm2m_interface_event_data_u* p_data)
{
    tr_debug("internal_event : new state %d", new_state);
    interface->event_data = p_data;
    interface->event_generated = true;
    interface->current_state = new_state;
    lwm2m_interface_state_engine(interface);
}

// the state engine executes the state machine states
static void lwm2m_interface_state_engine (lwm2m_interface_t *interface)
{
    tr_debug("state_engine");
    lwm2m_interface_event_data_u* p_data_temp = NULL;

    // while events are being generated keep executing states
    while (interface->event_generated) {
        p_data_temp = interface->event_data;  // copy of event data pointer
        interface->event_data = NULL;       // event data used up, reset ptr
        interface->event_generated = false;  // event used up, reset flag

        assert(interface->current_state < STATE_MAX_STATES);

        lwm2m_interface_state_function(interface, p_data_temp);
    }
}

static void lwm2m_interface_state_function(lwm2m_interface_t *interface, lwm2m_interface_event_data_u* data)
{
    switch( interface->current_state ) {
        case STATE_IDLE:
            lwm2m_interface_state_idle(interface, data);
            break;
        case STATE_BOOTSTRAP:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrap(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAP_ADDRESS_RESOLVED:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrap_address_resolved(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAP_RESOURCE_CREATED:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrap_resource_created(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAP_WAIT:
        case STATE_BOOTSTRAP_ERROR_WAIT:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            // Do nothing, we're just waiting for data_sent callback
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_BOOTSTRAPPED:
        #ifndef MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            lwm2m_interface_state_bootstrapped(interface, data);
        #endif //MBED_CONF_MBED_CLIENT_DISABLE_BOOTSTRAP_FEATURE
            break;
        case STATE_REGISTER:
            lwm2m_interface_state_register(interface, data);
            break;
        case STATE_REGISTER_ADDRESS_RESOLVED:
            lwm2m_interface_state_register_address_resolved(interface, data);
            break;
        case STATE_REGISTERED:
            lwm2m_interface_state_registered(interface, data);
            break;
        case STATE_UPDATE_REGISTRATION:
            lwm2m_interface_state_update_registration(interface, data);
            break;
        case STATE_UNREGISTER:
            lwm2m_interface_state_unregister(interface, data);
            break;
        case STATE_UNREGISTERED:
            lwm2m_interface_state_unregistered(interface, data);
            break;
        case STATE_SENDING_COAP_DATA:
            lwm2m_interface_state_sending_coap_data(interface, data);
            break;
        case STATE_COAP_DATA_SENT:
            lwm2m_interface_state_coap_data_sent(interface, data);
            break;
        case STATE_COAP_DATA_RECEIVED:
            lwm2m_interface_state_coap_data_received(interface, data);
            break;
        case STATE_PROCESSING_COAP_DATA:
            lwm2m_interface_state_processing_coap_data(interface, data);
            break;
        case STATE_COAP_DATA_PROCESSED:
            lwm2m_interface_state_coap_data_processed(interface, data);
            break;
        case STATE_WAITING:
            lwm2m_interface_state_waiting(interface, data);
            break;
    }
}

void lwm2m_interface_start_register_update(lwm2m_interface_t *interface, lwm2m_interface_event_data_u *data) {
    tr_debug("start_register_update()");

    MBED_ASSERT(interface != NULL);

    if(!data || (data->update_register_data.lifetime != 0 && (data->update_register_data.lifetime < MINIMUM_REGISTRATION_TIME))) {
        lwm2m_interface_set_error_description(interface, ERROR_REASON_18);
        lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_INVALID_PARAMETERS);
    }

    if (interface->reconnecting) {
        //If client is in reconnection mode, ignore this call, state machine will reconnect on its own.
        return;
    }

    interface->reconnection_state = LWM2M_INTERFACE_RECONNECTION_STATE_WITH_UPDATE;
    BEGIN_TRANSITION_MAP                                    // - Current State -
        TRANSITION_MAP_ENTRY (STATE_REGISTER)                // state_idle
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state__bootstrap_address_resolved
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_resource_created
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrap_error_wait
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_bootstrapped
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_register_address_resolved
        TRANSITION_MAP_ENTRY (STATE_UPDATE_REGISTRATION)    // state_registered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_update_registration
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregister
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_unregistered
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_sending_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_sent
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_received
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_processing_coap_data
        TRANSITION_MAP_ENTRY (EVENT_IGNORED)                // state_coap_data_processed
        TRANSITION_MAP_ENTRY (STATE_UPDATE_REGISTRATION)    // state_waiting
    END_TRANSITION_MAP(data)
    if(interface->event_ignored) {
        interface->event_ignored = false;
        if (!interface->reconnecting) {
            lwm2m_interface_set_error_description(interface, ERROR_REASON_19);
            lwm2m_interface_notify_observer(interface, LWM2M_INTERFACE_OBSERVER_EVENT_ERROR, LWM2M_INTERFACE_ERROR_NOT_ALLOWED);
        }
    }
}

void lwm2m_interface_update_endpoint(lwm2m_interface_t *interface, const char *name)
{
    //todo endpoint_set_parameters(&interface->endpoint, name, NULL, 0, NULL, NULL, 0);
}

void lwm2m_interface_update_domain(lwm2m_interface_t *interface, const char *domain)
{
    //todo endpoint_set_parameters(&interface->endpoint, NULL, NULL, 0, domain, NULL, 0);
}

const char* lwm2m_interface_internal_endpoint_name_str(const lwm2m_interface_t *interface)
{
    const char *iep = NULL;

    MBED_ASSERT(interface != NULL);

    if (interface->endpoint.location) {
        // Get last part of the location path.
        // In mbed Cloud environment full path is /rd/accountid/internal_endpoint
        iep = strrchr(interface->endpoint.location, '/');
        iep += 1;
    }

    return iep;
}


const char *lwm2m_interface_error_description(const lwm2m_interface_t *interface)
{
#ifdef DISABLE_ERROR_DESCRIPTION
    (void)interface;
    return "";
#else
    MBED_ASSERT(interface != NULL);
    return interface->error_description;
#endif
}

void lwm2m_interface_set_error_description(lwm2m_interface_t *interface, const char *description)
{
#ifdef DISABLE_ERROR_DESCRIPTION
    (void)interface;
    (void)description;
#else
    MBED_ASSERT(interface != NULL);
    interface->error_description = description;
#endif
}

bool lwm2m_interface_is_bootstrap_done(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    return interface->bootstrapped;
}

bool lwm2m_interface_is_bootstrap_waiting(lwm2m_interface_t *interface)
{
    MBED_ASSERT(interface != NULL);

    return (interface->current_state == STATE_BOOTSTRAP_WAIT);
}


static void lwm2m_interface_write_error_description(lwm2m_interface_t *interface, const char* reason, lwm2m_interface_error_t error_code)
{
    // Check that descriptions fits into buffer
#ifdef DISABLE_ERROR_DESCRIPTION
    (void)interface;
    (void)reason;
    (void)error_code;
#else
    const char *desc;
    switch(error_code) {
        case LWM2M_INTERFACE_ERROR_DNS_RESOLVING_FAILED:
            desc = ERROR_DNS;
            break;
        case LWM2M_INTERFACE_ERROR_SECURE_CONNECTION_FAILED:
            desc = ERROR_SECURE_CONNECTION;
            break;
        case LWM2M_INTERFACE_ERROR_CERTIFICATE_FAILED:
            desc = ERROR_CERTIFICATE_FAIL;
            break;
        case LWM2M_INTERFACE_ERROR_PLATFORM_FAULT:
            desc = ERROR_PLATFORM_FAIL;
            break;
        case LWM2M_INTERFACE_ERROR_INTERNAL_FAILURE:
            desc = ERROR_INTERNALFAILURE;
            break;
        case LWM2M_INTERFACE_ERROR_NETWORK_ERROR:
            desc = ERROR_NETWORK;
            break;
        case LWM2M_INTERFACE_ERROR_MEMORY_FAIL:
            desc = ERROR_MEMORY_FAIL;
            break;
        case LWM2M_INTERFACE_ERROR_UNREGISTRATION_FAILED:
            desc = ERROR_UNREGISTER_FAIL;
            break;
        default:
            desc = ERROR_NETWORK;
            break;
    }
    //todo: do we need the reason?
    interface->error_description = desc;

#endif
}


void lwm2m_interface_get_data_request(lwm2m_interface_t *interface,
                                      DownloadType type,
                                      const char *uri,
                                      const size_t offset,
                                      const bool async,
                                      get_data_cb data_cb,
                                      get_data_error_cb error_cb,
                                      void *context)
{
    get_data_req_error_t error = FAILED_TO_SEND_MSG;

    MBED_ASSERT(interface != NULL);

    if (interface->unregister_ongoing) {
        tr_error("get_data_request - unregister_ongoing");
        error_cb(ERROR_NOT_REGISTERED, context);
        return;
    }

    if (uri) {
        req_handler_send_data_request(&interface->endpoint, type, COAP_MSG_CODE_REQUEST_GET, uri, offset, async, data_cb, error_cb, context, NULL, 0);
    } else {
        error_cb(error, context);
    }
}

bool lwm2m_interface_set_uri_query_parameters(lwm2m_interface_t *interface, const char *uri_query_params)
{
    MBED_ASSERT(interface != NULL);

    return endpoint_set_uri_query_parameters(&interface->endpoint, uri_query_params);
}

static void lwm2m_interface_notify_observer(lwm2m_interface_t *interface, lwm2m_interface_observer_event_t event_id, lwm2m_interface_error_t event_type)
{
    if (interface->observer_id < 0 || !interface->observer) {
        tr_error("notify_observer() no observer set");
        return;
    }

    eventOS_cancel(&interface->observer_event);

    // we generate a preallocated event, which will be handled by the observer
    interface->observer_event.data.data_ptr = interface->observer;
    interface->observer_event.data.receiver = interface->observer_id;
    interface->observer_event.data.sender = 0;
    interface->observer_event.data.event_id = event_id;
    interface->observer_event.data.event_type = event_type;
    interface->observer_event.data.priority = ARM_LIB_LOW_PRIORITY_EVENT;

    eventOS_event_send_user_allocated(&interface->observer_event);
}

static bool lwm2m_interface_reset_timer(lwm2m_interface_t *interface, int8_t timer, int8_t tasklet_id, int32_t time_ms) {

    arm_event_t event;

    event.data_ptr = interface;
    event.event_data = 0;
    event.event_id = timer;
    event.event_type = 0; // Currently we have no use for event type.
    event.priority = ARM_LIB_LOW_PRIORITY_EVENT;
    event.receiver = tasklet_id;
    event.sender = tasklet_id;

    eventOS_event_timer_cancel(timer, tasklet_id);

    if (!eventOS_event_timer_request_in(&event, eventOS_event_timer_ms_to_ticks(time_ms))) {
        tr_error("reset_timer() call to eventOS_event_timer_request_in() failed");
        return false;
    }

    return true;
}

static lwm2m_interface_error_t lwm2m_interface_convert_protoman_to_client_error(int protoman_error) {
    tr_error("convert_protoman_to_client_error - protoman error %d", protoman_error);
    lwm2m_interface_error_t error = LWM2M_INTERFACE_ERROR_NETWORK_ERROR;
    switch(protoman_error) {
        case PROTOMAN_ERR_DNS_RESOLVING_FAILED:
            error = LWM2M_INTERFACE_ERROR_DNS_RESOLVING_FAILED;
            break;
        case PROTOMAN_ERR_SECURE_CONNECTION_FAILED:
            error = LWM2M_INTERFACE_ERROR_SECURE_CONNECTION_FAILED;
            break;
        case PROTOMAN_ERR_CERTIFICATE_CHECK_FAILED:
            error = LWM2M_INTERFACE_ERROR_CERTIFICATE_FAILED;
            break;
        case PROTOMAN_ERR_PLATFORM_FAULT:
            error = LWM2M_INTERFACE_ERROR_PLATFORM_FAULT;
            break;
        case PROTOMAN_ERR_INTERNAL_ERROR:
            error = LWM2M_INTERFACE_ERROR_INTERNAL_FAILURE;
            break;
        case PROTOMAN_ERR_NETWORK_ERROR:
        case PROTOMAN_ERR_CONNECTION_REFUSED:
            error = LWM2M_INTERFACE_ERROR_NETWORK_ERROR;
            break;
        default:
            error = LWM2M_INTERFACE_ERROR_NETWORK_ERROR; // default to network error
            break;
    }
    return error;
}
