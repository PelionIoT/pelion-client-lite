/*
 * Copyright (c) 2017 ARM Limited. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef LWM2M_REGISTRY_H
#define LWM2M_REGISTRY_H

//TODO: Resource updating check and notifying?
//TODO: Do we need support for multiple servers?
//TODO: Support for gateway?

#include "mbed-client/lwm2m_config.h"
#include "device-management-client/lwm2m_types.h"
#include "eventOS_event.h"
#include "singly_linked_list.h"
#include "sn_coap_header.h"

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

/** \file lwm2m_registry.h
 *  \brief Client Lite internal LwM2M Object registry API.
 */

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \brief Main data structure for Client Lite internal LwM2M Object registry.
 */
typedef struct registry_s {

    sll_t object_list; ///< For internal use only, MUST NOT be accessed from application.
    sll_t event_list; ///< For internal use only, MUST NOT be accessed from application.
#if MBED_CLIENT_ENABLE_AUTO_OBSERVATION
    uint16_t auto_obs_token; ///< For internal use only, MUST NOT be accessed from application.
#endif
    struct notifier_s *notifier; ///< For internal use only, MUST NOT be accessed from application.
} registry_t;

/**
 *  \brief Structure used for setting and getting the observation related data of a Resource.
 *
 *  \note Some fields are available only if the related flag in field `available` is set.
 */
typedef struct registry_observation_parameters_s {
#if MBED_CLIENT_ENABLE_OBSERVATION_PARAMETERS
    uint32_t pmin; ///< Minimum period, is not valid if the related flag is not set.
    uint32_t pmax; ///< Maximum period, is not valid if the related flag is not set.
    float gt; ///< Greater than, is not valid if the related flag is not set.
    float lt; ///< Less than, is not valid if the related flag is not set.
    float st; ///< Step, is not valid if the related flag is not set.
    uint32_t time; ///< Time of the last notification, is not valid if the related flag is not set.
    registry_observation_value_t previous_value; ///< Previous value notified, is not valid if the related flag is not set.
#endif
    sn_coap_content_format_e content_type; ///< Requested content type, is not valid if the related flag is not set.
    registry_available_parameters_t available; ///< Stores the information if the fields above are valid.
    uint8_t token[8]; ///< Token data.
    unsigned token_size:4; ///< Token size.
    bool dirty:1; ///< True indicates that the value has changed since the last notification.
    bool sent:1; ///< This field is used by the notifier.
                 ///< \note For internal use only, MUST NOT be accessed from application.
    bool observed:1; ///< Set as true if the related path has been observed.
} registry_observation_parameters_t;

#define LWM2M_VALUE_CACHE_MAX_AGE 0 ///< Maximum age for value caching in seconds. Default 0 seconds.

#define REGISTRY_PATH_OBJECT              0 ///< Object path.
                                            ///< \note Only field `object_id` is valid.
#define REGISTRY_PATH_OBJECT_INSTANCE     1 ///< Object Instance path.
                                            ///< \note Only fields `object_id` and `object_instance_id` are valid.
#define REGISTRY_PATH_RESOURCE            2 ///< Resource path.
                                            ///< \note Only fields `object_id`, `object_instance_id` and `resource_id` are valid.
#define REGISTRY_PATH_RESOURCE_INSTANCE   3 ///< Resource Instance path.
                                            ///< \note All ID field are valid.


#define REGISTRY_EVENT_ID 53 ///< ID for events generated by registry.
#define REGISTRY_EVENT_CHANGED 1 ///< Event type for event change related events.



/**
 * \brief Helper function for setting `registry_path_t` fields.
 *
 * \param path Pointer to the registry path to be initialized.
 * \param object Object ID.
 * \param object_instance Object Instance ID.
 * \param resource Resource ID.
 * \param resource_instance Resource Instance ID.
 * \param type Path type, possible values are: `REGISTRY_PATH_OBJECT`, `REGISTRY_PATH_OBJECT_INSTANCE`,
 *                        `REGISTRY_PATH_RESOURCE` and `REGISTRY_PATH_RESOURCE_INSTANCE`.
 *
 * NOTE:  Object MUST always have a proper value.
 *        IF type == `REGISTRY_PATH_OBJECT_INSTANCE`, `object_instance` MUST have a proper value. \n
 *        IF type == `REGISTRY_PATH_RESOURCE`, `object_instance` and `resource` MUST have proper values. \n
 *        IF type == `REGISTRY_PATH_RESOURCE_INSTANCE`, `object_instance`, `resource` and `resource_instance` MUST have proper values.
 */

void registry_set_path(registry_path_t *path,
                       const int16_t object,
                       const int16_t object_instance,
                       const int16_t resource,
                       const int16_t resource_instance,
                       const int8_t type);

/**
 * \brief Initialize a new registry. This function MUST be called before calling any other function.
 *
 * \param registry Pointer to the registry to be initialized.
 * \param notifier Pointer to the notifier the registry must use.
 *
 */
void registry_init(registry_t *registry, struct notifier_s *notifier);

/**
 * \brief Destroy a registry removing all Resources from it.
 *
 * \note After this call, the registry MUST NOT be used again without calling `registry_init`.
 *
 * \param registry MUST be a valid pointer initialized with `registry_init` OR NULL in which case nothing is done.
 *
 */
void registry_destroy(registry_t *registry);

/**
 * \brief Remove recursively everything under a given path from the registry.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Remove everything under this path.
 * \param removal_type Specify the type of object removal.
 *
 * \return REGISTRY_STATUS_OK Resource(s) removed successfully.
 * \return REGISTRY_STATUS_NOT_FOUND Resource not found.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter.
 *
 */
registry_status_t registry_remove_object(registry_t *registry, const registry_path_t *path, registry_removal_type_t removal_type);

/** \defgroup set_value Set a value.
 *
 * \brief Set value to a Resource.
 * \note Use the right setter for the Resource. The type of the value must match with Resource value type or the call will fail.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Path to the Resource.
 * \param value New value for the Resource. This will be copied to the internal structure.
 * \param free_on_remove Only available with string and opaque values. If true, the value will be freed after removing or modifying 
 * the Resource using `lwm2m_free()`.
 *
 * \return REGISTRY_STATUS_OK Data set.
 * \return REGISTRY_STATUS_NO_MEMORY Allocation of all or some of the Resources has failed.
 * \return REGISTRY_STATUS_NOT_FOUND Resource not found from static registry.
 * \return REGISTRY_STATUS_NO_DATA Resource has no data to set.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter or value type.
 */

/** \brief Set an integer.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_int(registry_t *registry, const registry_path_t *path, int64_t value); //!< \ingroup set_value
#if MBED_CLIENT_ENABLE_FLOAT_VALUE
/** \brief Set a float.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_float(registry_t *registry, const registry_path_t *path, float value); //!< \ingroup set_value
#endif
/** \brief Set a boolean.
 *
 * See detailed group description above for more information. */
registry_status_t registry_set_value_boolean(registry_t *registry, const registry_path_t *path, bool value); //!< \ingroup set_value
/** \brief Set a time.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_time(registry_t *registry, const registry_path_t *path, int64_t value); //!< \ingroup set_value
/*! \brief Set a string.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_string(registry_t *registry, const registry_path_t *path, const char *value, bool free_on_remove); //!< \ingroup set_value
/** \brief Set a string copy.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_string_copy(registry_t *registry, const registry_path_t *path, const uint8_t *value, size_t length); //!< \ingroup set_value
/** \brief Set an opaque.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_opaque(registry_t *registry, const registry_path_t *path, registry_data_opaque_t *value, bool free_on_remove); //!< \ingroup set_value
/** \brief Set an opaque copy.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_set_value_opaque_copy(registry_t *registry, const registry_path_t *path, const uint8_t *value, size_t length); //!< \ingroup set_value

/**
 * \brief Special function for setting an empty value for a Resource. Can be used for any type of Resource.
 *
 * See detailed group description above for parameter information.
 * \note The OMA LwM2M specification does not include an empty value or value type.
 */
registry_status_t registry_set_value_empty(registry_t *registry, const registry_path_t *path, bool empty); //!< \ingroup set_value

/** \defgroup get_value Read a value.
 *
 * \brief Read value from Resource.
 * \note Use the right getter for the resource. The type of the value must match with resource value type or the call will fail.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Path to Resource.
 * \param value Pointer to the value to get.
 *
 * \return REGISTRY_STATUS_OK Data read from Resource.
 * \return REGISTRY_STATUS_NOT_FOUND Resource not found.
 * \return REGISTRY_STATUS_NO_DATA Resource has no data to get. Indicates an empty value.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter or value type.
 */

 /** \brief Read an integer.
  *
  * See detailed group description above for parameter information. */
registry_status_t registry_get_value_int(const registry_t *registry, const registry_path_t *path, int64_t *value); //!< \ingroup get_value
#if MBED_CLIENT_ENABLE_FLOAT_VALUE
/** \brief Read a float.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_get_value_float(const registry_t *registry, const registry_path_t *path, float *value); //!< \ingroup get_value
#endif
/** \brief Read a boolean.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_get_value_boolean(const registry_t *registry, const registry_path_t *path, bool *value); //!< \ingroup get_value
/** \brief Read a time.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_get_value_time(const registry_t *registry, const registry_path_t *path, int64_t *value); //!< \ingroup get_value
/** \brief Read a string.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_get_value_string(const registry_t *registry, const registry_path_t *path, const char **value); //!< \ingroup get_value
/** \brief Read an opaque.
 *
 * See detailed group description above for parameter information. */
registry_status_t registry_get_value_opaque(const registry_t *registry, const registry_path_t *path, registry_data_opaque_t **value); //!< \ingroup get_value

/**
 * \brief Read empty value from Resource. Useful if you specifically want to check if a Resource was set empty.
 *        Otherwise you can call another function in this group and check for `REGISTRY_STATUS_NO_DATA`
 *        in the return value.
 *
 * See detailed group description above for parameter information.
 */
registry_status_t registry_get_value_empty(const registry_t *registry, const registry_path_t *path, bool *empty); //!< \ingroup get_value

/**
 * \brief Returns if the resource has empty value. Useful if you only want to check if a resource was set empty.
 */
registry_status_t registry_is_value_empty(const registry_t *registry, const registry_path_t *path, bool *empty);

/**
 * \brief Set maximum age in seconds for value caching.
 */
registry_status_t registry_set_max_age(registry_t *registry, const registry_path_t *path, uint32_t max_age);


/**
 * \brief Read the maximum age in seconds for value caching.
 */
registry_status_t registry_get_max_age(registry_t *registry, const registry_path_t *path, uint32_t *max_age);

/**
 * \brief Set observation parameters for Object.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Path to Object.
 * \param parameters Pointer to a structure that contains new parameters to be set for the Object.
 *
 * \return REGISTRY_STATUS_OK Data read from Resource.
 * \return REGISTRY_STATUS_NOT_FOUND Object not found.
 * \return REGISTRY_STATUS_NO_DATA Resource has no data to get.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter.
 */
registry_status_t registry_set_observation_parameters(registry_t *registry, const registry_path_t *path, const registry_observation_parameters_t *parameters);

//registry_status_t registry_update_observation_parameters(registry_t *registry, registry_path_t *path, registry_observation_parameters_t *parameters);

/**
 * \brief Read observation parameters from an Object.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Path to Object.
 * \param parameters Pointer to a structure where the parameters will be read.
 *
 * \return REGISTRY_STATUS_OK Data read from Resource.
 * \return REGISTRY_STATUS_NOT_FOUND Object not found.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter.
 */
registry_status_t registry_get_observation_parameters(const registry_t *registry, const registry_path_t *path, registry_observation_parameters_t *parameters);

/**
 * \brief Read value and observation parameters from resources one by one.
 * \note If parameter value or `parameters` is NULL, it will not be set.
 *
 * \param registry Pointer to the registry to be used.
 *
 * \param listing Set `listing_type` to `REGISTRY_LISTING_ALL` to list all Resources. \n
 *                Set `listing_type` to `REGISTRY_LISTING_RECURSIVE` to list all Resources under the path. \n
 *                Set `listing type` to `REGISTRY_LISTING_DIRECTORY` to list all registry objects directly under the given path. \n
 *                After a call, path will be set to the path of the Object currently read.
 *                Fields `value_set` and `parameters_set` indicate if the following parameters have been written.
 *                If `set_registered` is set to 1, registered field of the Resource will be set to 1.
 *                Field `registered` will indicate if the current Object has already been registered.
 * \note Field `set_registered` MUST be set to 0 before calling this function, unless building registration or registration update message.
 *
 * \param value If `value_set` field in listing is set, the value of the current Object is written to the structure pointed by this pointer.
 *
 * \param parameters If `parameters_set` field in listing is set, parameters of the current object are written to the structure pointed by this pointer.
 *
 * \return REGISTRY_STATUS_OK Data read, more Resources available. Make a new call using the same listing structure to continue.
 * \return REGISTRY_STATUS_NOT_FOUND Resource not found under path when using `REGISTRY_LISTING_RECURSIVE` mode.
 * \return REGISTRY_STATUS_NO_DATA No more Resources available. This function should not be called again without setting new listing parameters.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter.
 */
registry_status_t registry_get_objects(const registry_t *registry, registry_listing_t *listing, registry_object_value_t *value, registry_observation_parameters_t *parameters);

/**
 * \brief Register event handler for specific Resource events or all Resource events.
 *        This function only creates one event, and will not create a new event until `registry_event_processed` is called,
 *        even if there are multiple changes happening.
 *
 * \param registry Pointer to the registry to be used.
 * \param data_ptr Will be set to `arm_event_t.data_ptr` before sending the event.
 * \param mode Select the type of events to listen.
 * \param handler_id ID of the event handler.
 * \note The handler MUST be created using `eventOS_event_handler_create`.
 *
 * \return REGISTRY_STATUS_OK Registration OK.
 * \return REGISTRY_STATUS_NO_MEMORY Allocation of listener failed.
 * \return REGISTRY_STATUS_INVALID_INPUT Registry not set.
 */
registry_status_t registry_listen_events(registry_t *registry, void *data_ptr, registry_event_listen_mode_t mode, int8_t handler_id);

/**
 * \brief Mark the event as processed. MUST be called after receiving an event ordered by `registry_listen_events`.
 *
 * \param registry Pointer to the registry to be used.
 * \param event Received event ordered by `registry_listen_events`.
 *
 * \return REGISTRY_STATUS_OK Success.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid parameter.
 */
registry_status_t registry_event_processed(registry_t *registry, arm_event_s *event);

/**
 * \brief Stop receiving events ordered by `registry_listen_events`.
 *
 * \param registry Pointer to the registry to be used.
 * \param data_ptr Use the same value as used for registering.
 * \param mode Use the same value as used for registering.
 * \param handler_id Use the same value as used for registering.
 *
 * \return REGISTRY_STATUS_OK Registration removed.
 * \return REGISTRY_STATUS_NOT_FOUND Registration not found.
 * \return REGISTRY_STATUS_INVALID_INPUT Registry not set.
 */
registry_status_t registry_listen_events_stop(registry_t *registry, void *data_ptr, registry_event_listen_mode_t mode, int8_t handler_id);

/**
 * \brief Add new Object or Resource Instance. Instance ID will be the highest Instance ID + 1.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Create new instance under this path.
 * \note New Instance ID and path level will be set in this structure if the operation is successful.
 *
 * \return REGISTRY_STATUS_OK Instance created.
 */
registry_status_t registry_add_instance(registry_t *registry, registry_path_t *path);

/**
 * \brief Find out if the path exists in the registry.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Path to be checked.
 *
 * \return REGISTRY_STATUS_OK Path found in registry.
 * \return REGISTRY_STATUS_NOT_FOUND Path does not exist in registry.
 * \return REGISTRY_STATUS_INVALID_INPUT Bad arguments were given.
 */
registry_status_t registry_path_exists(registry_t *registry, registry_path_t *path);

/**
 * \brief Generic registry callback function type definition.
 *
 */
typedef registry_status_t (*registry_callback_t)(registry_callback_type_t,
                                                 const registry_path_t *,
                                                 const registry_callback_token_t*,
                                                 const registry_object_value_t*,
                                                 const registry_notification_status_t,
                                                 registry_t *);

/**
 * \brief Set callback function to specified registry object (path).
 *
 * \param registry Pointer to the registry to be used.
 * \param path Set callback to this registry path.
 * \param callback Callback function pointer.
 *
 * \return REGISTRY_STATUS_OK Valid registry object was found in the path.
 * \return REGISTRY_STATUS_NOT_FOUND No valid registry object was found in the path.
 * \return REGISTRY_STATUS_NO_DATA Callback cannot be set for the given path.
 */
registry_status_t registry_set_callback(registry_t *registry, const registry_path_t *path, registry_callback_t callback);

/**
 * \brief Get callback function for specified registry object (path).
 *
 * \param registry Pointer to the registry to be used.
 * \param path Get callback from this registry path.
 * \param callback Pointer to callback function pointer, where the callback function pointer is set after the call.
 *
 * \return REGISTRY_STATUS_OK Callback function was found in the path.
 * \return REGISTRY_STATUS_NOT_FOUND Callback not found.
 * \return REGISTRY_STATUS_NO_DATA Callback cannot be get from the given path.
 */
registry_status_t registry_get_callback(const registry_t *registry, const registry_path_t *path, registry_callback_t* callback);

/**
 * \brief Compare registry paths.
 *
 * \param path, path2 Contents compared to each other.
 *
 * \return True if all fields in paths are equal.
 */
bool registry_compare_path(const registry_path_t *path, const registry_path_t *path2);


/**
 * \brief Print a registry path.
 *
 * \param prefix String to print before the path.
 * \param path Registry path to print.
 *
 */
#if defined(MBED_CONF_MBED_TRACE_ENABLE) && (MBED_CONF_MBED_TRACE_ENABLE == 1)
#define print_registry_path(prefix, path) _print_registry_path(prefix, path)

// This is the real printer, that must be used with `print_registry_path()` as it lets the compiler to remove
// the format strings on non-tracing builds.
void _print_registry_path(const char *prefix, const registry_path_t *path);
#else
// Let the compiler leave prefix and format strings out of the binary.
#define print_registry_path(prefix, path) ((void) 0)
#endif

/**
 * \brief Find out if a given registry path has siblings on the same path level.
 *
 * \param registry Pointer to the registry to be used
 * \param path Registry path to check.
 * \param result True if a sibling is found in the registry.
 *
 * \return REGISTRY_STATUS_OK Verdict could be reached.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid arguments were given.
 */
registry_status_t registry_object_has_sibling(const registry_t *registry, const registry_path_t *path, bool *result);

/**
 * \brief Set Object to be auto-observable.
 *
 * \param registry Pointer to the registry to be used
 * \param path Registry path to check.
 * \param auto_observable Auto-observable feature enabled or disabled.
 *
 * \return REGISTRY_STATUS_OK In success.
 * \return REGISTRY_STATUS_INVALID_INPUT Invalid arguments were given.
 * \return REGISTRY_STATUS_NOT_FOUND Object not found.
 *
 */
registry_status_t registry_set_auto_observable_parameter(registry_t *registry, const registry_path_t *path, bool auto_observable);

/**
 * \brief Check whether Object is auto-observable.
 *
 * \param registry Pointer to the registry to be used.
 * \param path Registry path to check.
 *
 * \return True Auto-observation enabled.
 * \return False Auto-observation disabled.
 */
bool registry_is_auto_observable(registry_t *registry, const registry_path_t *path);

/**
 * \brief Include Resource value in the registration message. \n
 * This is only allowed for Resource types:
 * STRING \n
 * INTEGER \n
 * FLOAT \n
 * BOOLEAN
 *
 * \param registry Pointer to the registry to be used.
 * \param path Registry path to check.
 * \param publish_value If true, Resource value will be included in the registration message. Default value is false.
 *
 * \return REGISTRY_STATUS_OK Flag successfully set.
 * \return REGISTRY_STATUS_INVALID_INPUT Bad arguments were given.
 * \return REGISTRY_STATUS_NOT_FOUND Path not found in registry.
*/
registry_status_t registry_set_resource_value_to_reg_msg(registry_t *registry, const registry_path_t *path, bool publish_value);

/**
 * \brief Check whether Resource value is included in the registration message.
 *
 * \param registry Pointer to the registry to be used
 * \param path Registry path to check.
 *
 * \return True Resource value is included in the registration message.
 * \return False Resource value is not included in the registration message.
 */
bool registry_publish_resource_value_in_reg_msg(registry_t *registry, const registry_path_t *path);

uint32_t registry_object_count_resources(const registry_t *registry, const registry_path_t *path);

#ifdef __cplusplus
}
#endif

#endif //LWM2M_REGISTRY_H
